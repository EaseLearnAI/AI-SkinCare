
# ä»»åŠ¡ä¸€ï¼šä¿®æ”¹è‚Œè‚¤æ£€æµ‹é¡µé¢

æˆ‘å°†å¯¹`skin_detection_screen.dart`è¿›è¡Œä¿®æ”¹ï¼Œä½¿å…¶å¸ƒå±€å’Œæ ·å¼ä¸`skinstatus.html`æ›´åŠ ä¸€è‡´ã€‚

```dart:ai_skincare/lib/screens/skin_detection/skin_detection_screen.dart

```
æˆ‘å°†å¯¹`skin_detection_screen.dart`è¿›è¡Œä¿®æ”¹ï¼Œåˆ†éƒ¨åˆ†è¿›è¡Œæ›´æ–°ï¼š

```dart:ai_skincare/lib/screens/skin_detection/skin_detection_screen.dart

```
è®©æˆ‘åˆ†å‡ ä¸ªéƒ¨åˆ†ä¿®æ”¹skin_detection_screen.dart:

```dart:ai_skincare/lib/screens/skin_detection/skin_detection_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'dart:async';
import 'dart:io';
import 'package:image_picker/image_picker.dart';
import '../../themes/app_theme.dart';
import '../../widgets/bottom_nav_bar.dart';

class SkinDetectionScreen extends StatefulWidget {
  const SkinDetectionScreen({Key? key}) : super(key: key);

  @override
  _SkinDetectionScreenState createState() => _SkinDetectionScreenState();
}

class _SkinDetectionScreenState extends State<SkinDetectionScreen> with SingleTickerProviderStateMixin {
  final ImagePicker _picker = ImagePicker();
  File? _selectedImage;
  bool _isAnalyzing = false;
  bool _showQuiz = false;
  Timer? _analysisTimer;
  late AnimationController _scanAnimationController;
  late Animation<double> _scanAnimation;

  // è‚Œè‚¤æµ‹è¯•é—®å·é—®é¢˜
  final List<Map<String, dynamic>> _quizQuestions = [
    {
      'question': 'ä½ çš„çš®è‚¤ç±»å‹æ˜¯ä»€ä¹ˆï¼Ÿ',
      'options': ['å¹²æ€§', 'æ²¹æ€§', 'æ··åˆå‹', 'ä¸­æ€§', 'æ•æ„Ÿæ€§'],
      'selected': null,
    },
    {
      'question': 'ä½ ç›®å‰æœ‰å“ªäº›è‚Œè‚¤é—®é¢˜ï¼Ÿ',
      'options': ['æ¯›å­”ç²—å¤§', 'æš—æ²‰', 'ç—˜ç—˜', 'ç»†çº¹', 'æ— æ˜æ˜¾é—®é¢˜'],
      'multiSelect': true,
      'selected': <String>[],
    },
    {
      'question': 'ä½ çš„è‚Œè‚¤å¹³æ—¶æ˜¯å¦å®¹æ˜“è¿‡æ•ï¼Ÿ',
      'options': ['ç»å¸¸', 'å¶å°”', 'å¾ˆå°‘', 'ä»ä¸'],
      'selected': null,
    },
  ];

  @override
  void initState() {
    super.initState();
    _scanAnimationController = AnimationController(
      duration: const Duration(seconds: 2),
      vsync: this,
    )..repeat();
    
    _scanAnimation = Tween<double>(begin: -1.0, end: 2.0).animate(
      CurvedAnimation(
        parent: _scanAnimationController,
        curve: Curves.linear,
      ),
    );
  }

  @override
  void dispose() {
    _scanAnimationController.dispose();
    _analysisTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFFFF9FB), // AppTheme.sakuraPink100
      appBar: AppBar(
        elevation: 0,
        title: const Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.camera_alt, size: 18),
            SizedBox(width: 8),
            Text('è‚Œè‚¤æ£€æµ‹'),
          ],
        ),
        backgroundColor: AppTheme.sakuraPink500,
        foregroundColor: Colors.white,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Get.back(),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.history),
            onPressed: () {},
          ),
        ],
      ),
      body: _isAnalyzing
          ? _buildAnalyzingState()
          : _showQuiz
              ? _buildSkinQuiz()
              : _buildInitialState(),
      bottomNavigationBar: const BottomNavBar(currentIndex: 2),
    );
  }

  // åˆå§‹çŠ¶æ€ - é€‰æ‹©å›¾ç‰‡æˆ–æ‹ç…§
  Widget _buildInitialState() {
    return SingleChildScrollView(
      child: Column(
        children: [
          // ä¸»è¦å†…å®¹
          Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // ç›¸æœºåŒºåŸŸ
                _buildCameraArea(),
                
                const SizedBox(height: 24),
                
                // åˆ†æç»“æœåŒºåŸŸ
                _buildAnalysisResultsArea(),
                
                const SizedBox(height: 24),
                
                // AIå»ºè®®åŒºåŸŸ
                _buildAIRecommendationsArea(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  // ç›¸æœºåŒºåŸŸ
  Widget _buildCameraArea() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.pink.withOpacity(0.15),
            blurRadius: 20,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          // ç›¸æœºé¢„è§ˆåŒºåŸŸ
          Container(
            height: 200,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              gradient: LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: [Colors.blue[400]!, Colors.purple[400]!],
              ),
            ),
            child: Stack(
              children: [
                // ç›¸æœºé¢„è§ˆå†…å®¹
                if (_selectedImage != null)
                  ClipRRect(
                    borderRadius: BorderRadius.circular(12),
                    child: Image.file(
                      _selectedImage!,
                      width: double.infinity,
                      height: double.infinity,
                      fit: BoxFit.cover,
                    ),
                  ),
                
                // æ‰«æåŠ¨ç”»å±‚
                AnimatedBuilder(
                  animation: _scanAnimationController,
                  builder: (context, child) {
                    return Positioned(
                      left: 0,
                      right: 0,
                      top: _scanAnimation.value * 200,
                      height: 2,
                      child: Container(
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            colors: [
                              Colors.transparent,
                              AppTheme.sakuraPink500,
                              Colors.transparent,
                            ],
                          ),
                        ),
                      ),
                    );
                  },
                ),
                
                // çŒ«å’ªå›¾æ ‡å’Œæ–‡å­—å±‚
                if (_selectedImage == null)
                  Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        _buildFloatingImage(),
                        const SizedBox(height: 8),
                        const Text(
                          'è®©æˆ‘æ¥çœ‹çœ‹ä½ çš„è‚Œè‚¤çŠ¶æ€å–µï½',
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 14,
                          ),
                        ),
                      ],
                    ),
                  ),
                
                // æ‰«æè¾¹æ¡†
                Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(
                      color: Colors.white.withOpacity(0.3),
                      width: 2,
                    ),
                  ),
                ),
                
                // åº•éƒ¨é˜´å½±æ¸å˜
                Positioned(
                  left: 0,
                  right: 0,
                  bottom: 0,
                  height: 40,
                  child: Container(
                    decoration: BoxDecoration(
                      borderRadius: const BorderRadius.only(
                        bottomLeft: Radius.circular(12),
                        bottomRight: Radius.circular(12),
                      ),
                      gradient: LinearGradient(
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                        colors: [
                          Colors.transparent,
                          Colors.black.withOpacity(0.3),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          
          const SizedBox(height: 16),
          
          // ç›¸æœºæŒ‰é’®
          Row(
            children: [
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: _captureImage,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppTheme.sakuraPink500,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    elevation: 0,
                  ),
                  icon: const Icon(Icons.camera_alt),
                  label: const Text('æ‹ç…§æ£€æµ‹'),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: _pickImage,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.grey[100],
                    foregroundColor: Colors.grey[700],
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    elevation: 0,
                  ),
                  icon: const Icon(Icons.image),
                  label: const Text('ä»ç›¸å†Œé€‰æ‹©'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  // æµ®åŠ¨å›¾ç‰‡æ•ˆæœï¼ˆçŒ«å’ªå›¾æ ‡ï¼‰
  Widget _buildFloatingImage() {
    return TweenAnimationBuilder<double>(
      tween: Tween<double>(begin: 0, end: 1),
      duration: const Duration(seconds: 3),
      builder: (context, value, child) {
        return Transform.translate(
          offset: Offset(0, -10 * sin(value * 3.14 * 2)),
          child: child,
        );
      },
      child: Image.network(
        'https://i.imgur.com/QkIa5tS.png',
        width: 100,
        height: 100,
      ),
    );
  }
```

```dart:ai_skincare/lib/screens/skin_detection/skin_detection_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'dart:async';
import 'dart:io';
import 'dart:math';
import 'package:image_picker/image_picker.dart';
import '../../themes/app_theme.dart';
import '../../widgets/bottom_nav_bar.dart';

class SkinDetectionScreen extends StatefulWidget {
  const SkinDetectionScreen({Key? key}) : super(key: key);

  @override
  _SkinDetectionScreenState createState() => _SkinDetectionScreenState();
}

class _SkinDetectionScreenState extends State<SkinDetectionScreen> with SingleTickerProviderStateMixin {
  final ImagePicker _picker = ImagePicker();
  File? _selectedImage;
  bool _isAnalyzing = false;
  bool _showQuiz = false;
  Timer? _analysisTimer;
  late AnimationController _scanAnimationController;
  late Animation<double> _scanAnimation;

  // è‚Œè‚¤æµ‹è¯•é—®å·é—®é¢˜
  final List<Map<String, dynamic>> _quizQuestions = [
    {
      'question': 'ä½ çš„çš®è‚¤ç±»å‹æ˜¯ä»€ä¹ˆï¼Ÿ',
      'options': ['å¹²æ€§', 'æ²¹æ€§', 'æ··åˆå‹', 'ä¸­æ€§', 'æ•æ„Ÿæ€§'],
      'selected': null,
    },
    {
      'question': 'ä½ ç›®å‰æœ‰å“ªäº›è‚Œè‚¤é—®é¢˜ï¼Ÿ',
      'options': ['æ¯›å­”ç²—å¤§', 'æš—æ²‰', 'ç—˜ç—˜', 'ç»†çº¹', 'æ— æ˜æ˜¾é—®é¢˜'],
      'multiSelect': true,
      'selected': <String>[],
    },
    {
      'question': 'ä½ çš„è‚Œè‚¤å¹³æ—¶æ˜¯å¦å®¹æ˜“è¿‡æ•ï¼Ÿ',
      'options': ['ç»å¸¸', 'å¶å°”', 'å¾ˆå°‘', 'ä»ä¸'],
      'selected': null,
    },
  ];

  // åˆ†æç»“æœæ•°æ®
  final Map<String, dynamic> _analysisResults = {
    'hydration': {
      'value': 75,
      'status': 'çš®è‚¤æ°´åˆ†å……è¶³ï¼Œç»§ç»­ä¿æŒå–µï½',
      'trend': '+5%',
      'trendUp': true,
    },
    'oil': {
      'value': 60,
      'status': 'TåŒºæ²¹åˆ†ç•¥åé«˜ï¼Œå»ºè®®ä½¿ç”¨æ§æ²¹äº§å“å–µï½',
    },
    'sensitivity': {
      'value': 2,
      'maxValue': 5,
      'status': 'è½»åº¦æ•æ„Ÿï¼Œå»ºè®®ä½¿ç”¨æ¸©å’Œäº§å“å–µï½',
    },
  };

  // AIå»ºè®®æ•°æ®
  final List<Map<String, dynamic>> _recommendations = [
    {
      'title': 'åŠ å¼ºä¿æ¹¿é˜²æŠ¤',
      'description': 'å»ºè®®ä½¿ç”¨å«ç»å°¿é…¸çš„ä¿æ¹¿ç²¾åï¼Œæå‡è‚Œè‚¤æ°´æ¶¦åº¦',
      'icon': Icons.shield_outlined,
      'priority': 'ä¼˜å…ˆçº§é«˜',
      'timing': 'å»ºè®®ç«‹å³ä½¿ç”¨',
    },
    {
      'title': 'é˜²æ™’æé†’',
      'description': 'ä»Šæ—¥ç´«å¤–çº¿è¾ƒå¼ºï¼Œè®°å¾—æ¶‚é˜²æ™’å–µï½',
      'icon': Icons.wb_sunny,
    },
    {
      'title': 'æŠ¤ç†æ—¶é—´è¡¨',
      'description': 'æŸ¥çœ‹ä»Šæ—¥æŠ¤ç†æ—¶é—´å®‰æ’',
      'icon': Icons.access_time,
    },
  ];

  @override
  void initState() {
    super.initState();
    _scanAnimationController = AnimationController(
      duration: const Duration(seconds: 2),
      vsync: this,
    )..repeat();
    
    _scanAnimation = Tween<double>(begin: -1.0, end: 2.0).animate(
      CurvedAnimation(
        parent: _scanAnimationController,
        curve: Curves.linear,
      ),
    );
  }

  @override
  void dispose() {
    _scanAnimationController.dispose();
    _analysisTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFFFF9FB), // AppTheme.sakuraPink100
      appBar: AppBar(
        elevation: 0,
        title: const Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.camera_alt, size: 18),
            SizedBox(width: 8),
            Text('è‚Œè‚¤æ£€æµ‹'),
          ],
        ),
        backgroundColor: AppTheme.sakuraPink500,
        foregroundColor: Colors.white,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Get.back(),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.history),
            onPressed: () {},
          ),
        ],
      ),
      body: _isAnalyzing
          ? _buildAnalyzingState()
          : _showQuiz
              ? _buildSkinQuiz()
              : _buildInitialState(),
      bottomNavigationBar: const BottomNavBar(currentIndex: 2),
    );
  }

  // åˆå§‹çŠ¶æ€ - é€‰æ‹©å›¾ç‰‡æˆ–æ‹ç…§
  Widget _buildInitialState() {
    return SingleChildScrollView(
      child: Column(
        children: [
          // ä¸»è¦å†…å®¹
          Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // ç›¸æœºåŒºåŸŸ
                _buildCameraArea(),
                
                const SizedBox(height: 24),
                
                // åˆ†æç»“æœåŒºåŸŸ
                _buildAnalysisResultsArea(),
                
                const SizedBox(height: 24),
                
                // AIå»ºè®®åŒºåŸŸ
                _buildAIRecommendationsArea(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  // ç›¸æœºåŒºåŸŸ
  Widget _buildCameraArea() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.pink.withOpacity(0.15),
            blurRadius: 20,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          // ç›¸æœºé¢„è§ˆåŒºåŸŸ
          Container(
            height: 200,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              gradient: LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: [Colors.blue[400]!, Colors.purple[400]!],
              ),
            ),
            child: Stack(
              children: [
                // ç›¸æœºé¢„è§ˆå†…å®¹
                if (_selectedImage != null)
                  ClipRRect(
                    borderRadius: BorderRadius.circular(12),
                    child: Image.file(
                      _selectedImage!,
                      width: double.infinity,
                      height: double.infinity,
                      fit: BoxFit.cover,
                    ),
                  ),
                
                // æ‰«æåŠ¨ç”»å±‚
                AnimatedBuilder(
                  animation: _scanAnimationController,
                  builder: (context, child) {
                    return Positioned(
                      left: 0,
                      right: 0,
                      top: _scanAnimation.value * 200,
                      height: 2,
                      child: Container(
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            colors: [
                              Colors.transparent,
                              AppTheme.sakuraPink500,
                              Colors.transparent,
                            ],
                          ),
                        ),
                      ),
                    );
                  },
                ),
                
                // çŒ«å’ªå›¾æ ‡å’Œæ–‡å­—å±‚
                if (_selectedImage == null)
                  Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        _buildFloatingImage(),
                        const SizedBox(height: 8),
                        const Text(
                          'è®©æˆ‘æ¥çœ‹çœ‹ä½ çš„è‚Œè‚¤çŠ¶æ€å–µï½',
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 14,
                          ),
                        ),
                      ],
                    ),
                  ),
                
                // æ‰«æè¾¹æ¡†
                Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(
                      color: Colors.white.withOpacity(0.3),
                      width: 2,
                    ),
                  ),
                ),
                
                // åº•éƒ¨é˜´å½±æ¸å˜
                Positioned(
                  left: 0,
                  right: 0,
                  bottom: 0,
                  height: 40,
                  child: Container(
                    decoration: BoxDecoration(
                      borderRadius: const BorderRadius.only(
                        bottomLeft: Radius.circular(12),
                        bottomRight: Radius.circular(12),
                      ),
                      gradient: LinearGradient(
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                        colors: [
                          Colors.transparent,
                          Colors.black.withOpacity(0.3),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          
          const SizedBox(height: 16),
          
          // ç›¸æœºæŒ‰é’®
          Row(
            children: [
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: _captureImage,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppTheme.sakuraPink500,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    elevation: 0,
                  ),
                  icon: const Icon(Icons.camera_alt),
                  label: const Text('æ‹ç…§æ£€æµ‹'),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: _pickImage,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.grey[100],
                    foregroundColor: Colors.grey[700],
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    elevation: 0,
                  ),
                  icon: const Icon(Icons.image),
                  label: const Text('ä»ç›¸å†Œé€‰æ‹©'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  // æµ®åŠ¨å›¾ç‰‡æ•ˆæœï¼ˆçŒ«å’ªå›¾æ ‡ï¼‰
  Widget _buildFloatingImage() {
    return TweenAnimationBuilder<double>(
      tween: Tween<double>(begin: 0, end: 1),
      duration: const Duration(seconds: 3),
      builder: (context, value, child) {
        return Transform.translate(
          offset: Offset(0, -10 * sin(value * 3.14 * 2)),
          child: child,
        );
      },
      child: Image.network(
        'https://i.imgur.com/QkIa5tS.png',
        width: 100,
        height: 100,
      ),
    );
  }

  // åˆ†æç»“æœåŒºåŸŸ
  Widget _buildAnalysisResultsArea() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.pink.withOpacity(0.15),
            blurRadius: 20,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // æ ‡é¢˜
          Row(
            children: const [
              Text(
                'ğŸ”',
                style: TextStyle(fontSize: 18),
              ),
              SizedBox(width: 8),
              Text(
                'ä»Šæ—¥è‚Œè‚¤çŠ¶æ€',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          
          // æ°´åˆ†çŠ¶æ€å¡ç‰‡
          _buildHydrationCard(),
          
          const SizedBox(height: 16),
          
          // æ²¹åˆ†çŠ¶æ€å¡ç‰‡
          _buildOilCard(),
          
          const SizedBox(height: 16),
          
          // æ•æ„Ÿç¨‹åº¦å¡ç‰‡
          _buildSensitivityCard(),
        ],
      ),
    );
  }

  // æ°´åˆ†çŠ¶æ€å¡ç‰‡
  Widget _buildHydrationCard() {
    final hydrationData = _analysisResults['hydration'] as Map<String, dynamic>;
    final double hydrationValue = hydrationData['value'].toDouble();
    
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.blue[50],
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // è¿›åº¦ç¯
          SizedBox(
            width: 60,
            height: 60,
            child: CustomPaint(
              painter: ProgressRingPainter(
                progress: hydrationValue / 100,
                baseColor: Colors.blue[100]!,
                progressColor: Colors.blue[500]!,
                strokeWidth: 4,
              ),
              child: Center(
                child: Text(
                  '${hydrationValue.toInt()}%',
                  style: TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                    color: Colors.blue[500],
                  ),
                ),
              ),
            ),
          ),
          const SizedBox(width: 16),
          
          // å†…å®¹
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Icon(Icons.water_drop, size: 18, color: Colors.blue[500]),
                    const SizedBox(width: 8),
                    const Text(
                      'æ°´åˆ†çŠ¶æ€',
                      style: TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                Text(
                  hydrationData['status'],
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey[600],
                  ),
                ),
                const SizedBox(height: 4),
                Row(
                  children: [
                    Icon(
                      hydrationData['trendUp'] ? Icons.arrow_upward : Icons.arrow_downward,
                      size: 14,
                      color: Colors.blue[500],
                    ),
                    const SizedBox(width: 4),
                    Text(
                      'è¾ƒæ˜¨æ—¥${hydrationData['trend']}',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.blue[500],
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  // æ²¹åˆ†çŠ¶æ€å¡ç‰‡
  Widget _buildOilCard() {
    final oilData = _analysisResults['oil'] as Map<String, dynamic>;
    final double oilValue = oilData['value'].toDouble();
    
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.yellow[50],
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Row(
                children: [
                  Icon(Icons.oil_barrel, size: 18, color: Colors.yellow[700]),
                  const SizedBox(width: 8),
                  const Text(
                    'æ²¹åˆ†çŠ¶æ€',
                    style: TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
              Text(
                '${oilValue.toInt()}%',
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.yellow[700],
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          
          // è¿›åº¦æ¡
          ClipRRect(
            borderRadius: BorderRadius.circular(2),
            child: LinearProgressIndicator(
              value: oilValue / 100,
              backgroundColor: Colors.yellow[100],
              valueColor: AlwaysStoppedAnimation<Color>(Colors.yellow[400]!),
              minHeight: 8,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            oilData['status'],
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey[600],
            ),
          ),
        ],
      ),
    );
  }

  // æ•æ„Ÿç¨‹åº¦å¡ç‰‡
  Widget _buildSensitivityCard() {
    final sensitivityData = _analysisResults['sensitivity'] as Map<String, dynamic>;
    final int sensitivityValue = sensitivityData['value'] as int;
    final int maxValue = sensitivityData['maxValue'] as int;
    
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.red[50],
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Row(
                children: [
                  Icon(Icons.warning_amber_rounded, size: 18, color: Colors.red[500]),
                  const SizedBox(width: 8),
                  const Text(
                    'æ•æ„Ÿç¨‹åº¦',
                    style: TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
              // èŠ±ç“£è¿›åº¦æŒ‡ç¤ºå™¨
              Row(
                children: List.generate(maxValue, (index) {
                  final isActive = index < sensitivityValue;
                  return Padding(
                    padding: const EdgeInsets.only(left: 4),
                    child: Transform.rotate(
                      angle: pi / 4,
                      child: Container(
                        width: 15,
                        height: 15,
                        decoration: BoxDecoration(
                          borderRadius: const BorderRadius.only(
                            topRight: Radius.circular(15),
                            bottomLeft: Radius.circular(15),
                          ),
                          color: isActive
                              ? AppTheme.sakuraPink500
                              : AppTheme.sakuraPink500.withOpacity(0.3),
                        ),
                      ),
                    ),
                  );
                }),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            sensitivityData['status'],
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey[600],
            ),
          ),
        ],
      ),
    );
  }

  // AIå»ºè®®åŒºåŸŸ
  Widget _buildAIRecommendationsArea() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.pink.withOpacity(0.15),
            blurRadius: 20,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // æ ‡é¢˜
          Row(
            children: const [
              Text(
                'ğŸ±',
                style: TextStyle(fontSize: 18),
              ),
              SizedBox(width: 8),
              Text(
                'çŒ«å’ªçš„æŠ¤ç†å»ºè®®',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          
          // å»ºè®®å¡ç‰‡åˆ—è¡¨
          ...List.generate(_recommendations.length, (index) {
            final recommendation = _recommendations[index];
            
            // ä¸»è¦å»ºè®®å¡ç‰‡ï¼ˆè¾ƒå¤§ï¼‰
            if (index == 0) {
              return Container(
                margin: const EdgeInsets.only(bottom: 12),
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: AppTheme.sakuraPink100,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // å›¾æ ‡
                    Container(
                      width: 48,
                      height: 48,
                      decoration: BoxDecoration(
                        color: AppTheme.sakuraPink300,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Icon(
                        recommendation['icon'],
                        color: Colors.white,
                        size: 24,
                      ),
                    ),
                    const SizedBox(width: 16),
                    
                    // å†…å®¹
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Text(
                                recommendation['title'],
                                style: const TextStyle(
                                  fontSize: 14,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                              _buildPriorityTag(recommendation['priority']),
                            ],
                          ),
                          const SizedBox(height: 4),
                          Text(
                            recommendation['description'],
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.grey[600],
                            ),
                          ),
                          const SizedBox(height: 8),
                          Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Row(
                                children: [
                                  Icon(
                                    Icons.access_time,
                                    size: 12,
                                    color: AppTheme.sakuraPink500,
                                  ),
                                  const SizedBox(width: 4),
                                  Text(
                                    recommendation['timing'],
                                    style: TextStyle(
                                      fontSize: 12,
                                      color: AppTheme.sakuraPink500,
                                    ),
                                  ),
                                ],
                              ),
                              Text(
                                'æŸ¥çœ‹æ¨èäº§å“',
                                style: TextStyle(
                                  fontSize: 12,
                                  color: AppTheme.sakuraPink500,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              );
            }
            
            // æ¬¡è¦å»ºè®®å¡ç‰‡ï¼ˆè¾ƒå°ï¼‰
            return Container(
              margin: const EdgeInsets.only(bottom: 8),
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: AppTheme.sakuraPink100,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  // å›¾æ ‡
                  Container(
                    width: 40,
                    height: 40,
                    decoration: BoxDecoration(
                      color: AppTheme.sakuraPink300,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Icon(
                      recommendation['icon'],
                      color: Colors.white,
                      size: 20,
                    ),
                  ),
                  const SizedBox(width: 12),
                  
                  // å†…å®¹
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          recommendation['title'],
                          style: const TextStyle(
                            fontSize: 14,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                        const SizedBox(height: 2),
                        Text(
                          recommendation['description'],
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.grey[600],
                          ),
                        ),
                      ],
                    ),
                  ),
                  Icon(
                    Icons.chevron_right,
                    color: AppTheme.sakuraPink500,
                  ),
                ],
              ),
            );
          }),
        ],
      ),
    );
  }

  // ä¼˜å…ˆçº§æ ‡ç­¾
  Widget _buildPriorityTag(String? priority) {
    if (priority == null) return const SizedBox.shrink();
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: AppTheme.sakuraPink200,
        borderRadius: BorderRadius.circular(30),
      ),
      child: Text(
        priority,
        style: TextStyle(
          fontSize: 10,
          color: AppTheme.sakuraPink700,
        ),
      ),
    );
  }

  // æ‹ç…§
  Future<void> _captureImage() async {
    try {
      final XFile? image = await _picker.pickImage(source: ImageSource.camera);
      if (image != null) {
        setState(() {
          _selectedImage = File(image.path);
        });
      }
    } catch (e) {
      // å¤„ç†ç›¸æœºæƒé™ç­‰é”™è¯¯
      Get.snackbar(
        'é”™è¯¯',
        'æ— æ³•è®¿é—®ç›¸æœºï¼Œè¯·æ£€æŸ¥åº”ç”¨æƒé™è®¾ç½®',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.red,
        colorText: Colors.white,
        margin: const EdgeInsets.all(16),
        duration: const Duration(seconds: 3),
      );
    }
  }

  // ä»ç›¸å†Œé€‰æ‹©
  Future<void> _pickImage() async {
    try {
      final XFile? image = await _picker.pickImage(source: ImageSource.gallery);
      if (image != null) {
        setState(() {
          _selectedImage = File(image.path);
        });
      }
    } catch (e) {
      // å¤„ç†ç›¸å†Œæƒé™ç­‰é”™è¯¯
      Get.snackbar(
        'é”™è¯¯',
        'æ— æ³•è®¿é—®ç›¸å†Œï¼Œè¯·æ£€æŸ¥åº”ç”¨æƒé™è®¾ç½®',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.red,
        colorText: Colors.white,
        margin: const EdgeInsets.all(16),
        duration: const Duration(seconds: 3),
      );
    }
  }

  // å¼€å§‹åˆ†æ
  void _startAnalysis() {
    setState(() {
      _isAnalyzing = true;
    });

    // æ¨¡æ‹Ÿåˆ†æè¿‡ç¨‹
    _analysisTimer = Timer(const Duration(seconds: 3), () {
      // è¿™é‡Œåº”è¯¥æ˜¯è°ƒç”¨APIè¿›è¡Œå®é™…åˆ†æ
      // åˆ†æå®Œæˆåï¼Œè½¬åˆ°ç»“æœé¡µé¢
      Get.toNamed('/skin_result');
    });
  }
}
```

```dart:ai_skincare/lib/screens/skin_detection/skin_detection_screen.dart
// åˆ†æä¸­çŠ¶æ€
  Widget _buildAnalyzingState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // è„‰åŠ¨å…‰ç¯æ•ˆæœ
          Container(
            width: 120,
            height: 120,
            decoration: BoxDecoration(
              color: Colors.white,
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(
                  color: AppTheme.sakuraPink200.withOpacity(0.5),
                  blurRadius: 20,
                  spreadRadius: 5,
                ),
              ],
            ),
            child: Center(
              child: SizedBox(
                width: 64,
                height: 64,
                child: CircularProgressIndicator(
                  valueColor: AlwaysStoppedAnimation<Color>(
                    AppTheme.sakuraPink500,
                  ),
                  strokeWidth: 4,
                ),
              ),
            ),
          ),
          const SizedBox(height: 32),
          const Text(
            'AIæ­£åœ¨åˆ†ææ‚¨çš„è‚Œè‚¤...',
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
              color: Color(0xFF333333),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'æˆ‘ä»¬æ­£åœ¨æ£€æµ‹å¤šé¡¹è‚Œè‚¤æŒ‡æ ‡,è¯·ç¨å€™...',
            style: TextStyle(
              fontSize: 14,
              color: Colors.grey[600],
            ),
          ),
          const SizedBox(height: 48),
          Column(
            children: [
              _buildAnalysisStep('æ£€æµ‹è‚¤è´¨ç±»å‹', true),
              _buildAnalysisStep('æ£€æµ‹è‚Œè‚¤æ°´åˆ†', true),
              _buildAnalysisStep('æ£€æµ‹æ¯›å­”çŠ¶å†µ', true),
              _buildAnalysisStep('æ£€æµ‹è‚Œè‚¤æ•æ„Ÿåº¦', false),
              _buildAnalysisStep('ç”Ÿæˆä¸ªæ€§åŒ–å»ºè®®', false),
            ],
          ),
        ],
      ),
    );
  }

  // åˆ†ææ­¥éª¤
  Widget _buildAnalysisStep(String step, bool completed) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            width: 24,
            height: 24,
            decoration: BoxDecoration(
              color: completed ? AppTheme.sakuraPink500 : Colors.grey[300],
              shape: BoxShape.circle,
            ),
            child: Center(
              child: Icon(
                completed ? Icons.check : Icons.hourglass_empty,
                color: Colors.white,
                size: 16,
              ),
            ),
          ),
          const SizedBox(width: 8),
          Text(
            step,
            style: TextStyle(
              fontSize: 14,
              fontWeight: completed ? FontWeight.w500 : FontWeight.normal,
              color:
                  completed ? AppTheme.sakuraPink500 : Colors.grey[600],
            ),
          ),
        ],
      ),
    );
  }

  // è‚Œè‚¤æµ‹è¯•é—®å·
  Widget _buildSkinQuiz() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: AppTheme.sakuraPink100,
              borderRadius: BorderRadius.circular(12),
            ),
            child: Column(
              children: [
                Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: AppTheme.sakuraPink500,
                        shape: BoxShape.circle,
                      ),
                      child: const Icon(
                        Icons.assignment_outlined,
                        color: Colors.white,
                        size: 18,
                      ),
                    ),
                    const SizedBox(width: 12),
                    const Expanded(
                      child: Text(
                        'è‚Œè‚¤æµ‹è¯•é—®å·',
                        style: TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                          color: Color(0xFF333333),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                const Text(
                  'è¯·å›ç­”ä»¥ä¸‹é—®é¢˜ï¼Œå¸®åŠ©æˆ‘ä»¬æ›´å‡†ç¡®åœ°äº†è§£æ‚¨çš„è‚Œè‚¤çŠ¶å†µã€‚',
                  style: TextStyle(
                    fontSize: 14,
                    color: Color(0xFF666666),
                    height: 1.5,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 24),

          // é—®å·é—®é¢˜
          ...List.generate(_quizQuestions.length, (index) {
            final question = _quizQuestions[index];
            return _buildQuizQuestion(index, question);
          }),

          const SizedBox(height: 24),

          // æäº¤æŒ‰é’®
          ElevatedButton(
            onPressed:
                _isQuizValid()
                    ? () {
                      setState(() {
                        _isAnalyzing = true;
                        _showQuiz = false;
                      });

                      // æ¨¡æ‹Ÿåˆ†æè¿‡ç¨‹
                      _analysisTimer = Timer(const Duration(seconds: 3), () {
                        // å¤„ç†é—®å·åˆ†æç»“æœ
                        Get.toNamed('/skin_result');
                      });
                    }
                    : null,
            style: ElevatedButton.styleFrom(
              backgroundColor: AppTheme.sakuraPink500,
              foregroundColor: Colors.white,
              disabledBackgroundColor: Colors.grey[300],
              padding: const EdgeInsets.symmetric(vertical: 16),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
            child: const Text('æäº¤é—®å·', style: TextStyle(fontSize: 16)),
          ),

          const SizedBox(height: 16),

          // è¿”å›æŒ‰é’®
          OutlinedButton(
            onPressed: () {
              setState(() {
                _showQuiz = false;
              });
            },
            style: OutlinedButton.styleFrom(
              foregroundColor: Colors.grey[700],
              padding: const EdgeInsets.symmetric(vertical: 16),
              side: BorderSide(color: Colors.grey[400]!),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
            child: const Text('è¿”å›ä¸Šä¸€æ­¥', style: TextStyle(fontSize: 16)),
          ),
        ],
      ),
    );
  }

  // æ„å»ºé—®å·é—®é¢˜
  Widget _buildQuizQuestion(int index, Map<String, dynamic> question) {
    final isMultiSelect = question['multiSelect'] ?? false;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text(
              'Q${index + 1}',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
                color: AppTheme.sakuraPink500,
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: Text(
                question['question'] as String,
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                  color: Color(0xFF333333),
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: 12),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: List.generate((question['options'] as List).length, (
            optionIndex,
          ) {
            final option = question['options'][optionIndex];
            bool isSelected = false;

            if (isMultiSelect) {
              isSelected = (question['selected'] as List<String>).contains(
                option,
              );
            } else {
              isSelected = question['selected'] == option;
            }

            return GestureDetector(
              onTap: () {
                setState(() {
                  if (isMultiSelect) {
                    final selectedList = question['selected'] as List<String>;
                    if (isSelected) {
                      selectedList.remove(option);
                    } else {
                      selectedList.add(option);
                    }
                  } else {
                    _quizQuestions[index]['selected'] = option;
                  }
                });
              },
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 8,
                ),
                decoration: BoxDecoration(
                  color: isSelected ? AppTheme.sakuraPink100 : Colors.white,
                  borderRadius: BorderRadius.circular(30),
                  border: Border.all(
                    color:
                        isSelected ? AppTheme.sakuraPink500 : Colors.grey[300]!,
                  ),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (isSelected)
                      Container(
                        width: 16,
                        height: 16,
                        margin: const EdgeInsets.only(right: 6),
                        decoration: BoxDecoration(
                          color: AppTheme.sakuraPink500,
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(
                          Icons.check,
                          size: 12,
                          color: Colors.white,
                        ),
                      ),
                    Text(
                      option,
                      style: TextStyle(
                        color:
                            isSelected
                                ? AppTheme.sakuraPink500
                                : Colors.grey[700],
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
              ),
            );
          }),
        ),
        const SizedBox(height: 24),
      ],
    );
  }

  // æ£€æŸ¥é—®å·æ˜¯å¦æœ‰æ•ˆ
  bool _isQuizValid() {
    bool isValid = true;

    for (final question in _quizQuestions) {
      final isMultiSelect = question['multiSelect'] ?? false;

      if (isMultiSelect) {
        final selectedList = question['selected'] as List<String>;
        if (selectedList.isEmpty) {
          isValid = false;
          break;
        }
      } else {
        if (question['selected'] == null) {
          isValid = false;
          break;
        }
      }
    }

    return isValid;
  }
}

// è¿›åº¦ç¯ç»˜åˆ¶å™¨
class ProgressRingPainter extends CustomPainter {
  final double progress;
  final Color baseColor;
  final Color progressColor;
  final double strokeWidth;

  ProgressRingPainter({
    required this.progress,
    required this.baseColor,
    required this.progressColor,
    this.strokeWidth = 4.0,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = (size.width - strokeWidth) / 2;
    
    // ç»˜åˆ¶åº•ç¯
    final basePaint = Paint()
      ..color = baseColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = strokeWidth
      ..strokeCap = StrokeCap.round;
    
    canvas.drawCircle(center, radius, basePaint);
    
    // ç»˜åˆ¶è¿›åº¦ç¯
    final progressPaint = Paint()
      ..color = progressColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = strokeWidth
      ..strokeCap = StrokeCap.round;
    
    final rect = Rect.fromCircle(center: center, radius: radius);
    
    // è®¡ç®—èµ·å§‹å’Œç»“æŸè§’åº¦ï¼ˆè¿›åº¦ç¯ä»é¡¶éƒ¨å¼€å§‹ï¼Œé€†æ—¶é’ˆæ–¹å‘ï¼‰
    const startAngle = -pi / 2;  // ä»ä¸Šæ–¹å¼€å§‹
    final sweepAngle = 2 * pi * progress;  // æ‰«è¿‡çš„è§’åº¦
    
    canvas.drawArc(rect, startAngle, sweepAngle, false, progressPaint);
  }

  @override
  bool shouldRepaint(covariant ProgressRingPainter oldDelegate) {
    return oldDelegate.progress != progress ||
           oldDelegate.baseColor != baseColor ||
           oldDelegate.progressColor != progressColor ||
           oldDelegate.strokeWidth != strokeWidth;
  }
}
```
ç°åœ¨æˆ‘å·²ç»å®Œæˆäº†è‚Œè‚¤æ£€æµ‹é¡µé¢çš„ä¿®æ”¹ï¼Œé¡µé¢ä¸skinstatus.htmlçš„æ ·å¼å’Œå¸ƒå±€ä¿æŒä¸€è‡´ã€‚æ¥ä¸‹æ¥è®©æˆ‘ä¸ºæ•´ä¸ªé¡¹ç›®ç”Ÿæˆä¸€ä¸ªåç«¯æ¥å£æ–‡æ¡£ã€‚

Ran tool
è®©æˆ‘å†å°è¯•æŸ¥çœ‹é¡¹ç›®ç»“æ„ï¼Œä»¥ä¾¿ç”Ÿæˆåˆé€‚çš„åç«¯æ¥å£æ–‡æ¡£ï¼š

```bash
find ai_skincare/lib -type d | sort
```
è®©æˆ‘å†è¯•ä¸€æ¬¡æŸ¥çœ‹é¡¹ç›®ç»“æ„ï¼š

```bash
find ai_skincare/lib -type d
```
æˆ‘å°†ä½¿ç”¨å¦ä¸€ç§æ–¹å¼æŸ¥çœ‹é¡¹ç›®ç»“æ„ï¼š

```bash
ls -la ai_skincare/lib/
```
è®©æˆ‘é€šè¿‡grepæœç´¢æ¥äº†è§£é¡¹ç›®ç»“æ„ï¼š

Ran tool
ç°åœ¨è®©æˆ‘æŸ¥çœ‹é¡¹ç›®ç›®å½•ç»“æ„ï¼š

Ran tool
è®©æˆ‘æŸ¥çœ‹skinstatus.htmlæ–‡ä»¶ï¼š

Ran tool

Read file: d:\AI\project\AI-SkinCare\prototype\pages\skinstatus.html

Read file: prototype/pages/skinstatus.html
ç°åœ¨è®©æˆ‘æŸ¥çœ‹å½“å‰çš„è‚Œè‚¤æ£€æµ‹å±å¹•å®ç°ï¼š

Read file: ai_skincare/lib/screens/skin_detection/skin_detection_screen.dart
ç°åœ¨è®©æˆ‘åˆ†æåœ¨skinstatus.htmlä¸­çš„å…ƒç´ å’ŒUIè®¾è®¡ï¼Œä¸å½“å‰çš„Flutterå®ç°è¿›è¡Œå¯¹æ¯”ï¼Œå¹¶å‡†å¤‡ç”Ÿæˆåç«¯APIæ–‡æ¡£ã€‚

Ran tool

Ran tool
ç°åœ¨æˆ‘å°†åˆ›å»ºAPIæ¥å£æ–‡æ¡£å’Œå¯¹åº”çš„æ•°æ®æ¨¡å‹ï¼š

```markdown:api_documentation.md
# AI è‚Œè‚¤æ£€æµ‹åº”ç”¨ç¨‹åº API æ–‡æ¡£

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†AIè‚Œè‚¤æ£€æµ‹åº”ç”¨ç¨‹åºçš„åç«¯APIæ¥å£ã€‚è¯¥åº”ç”¨ç¨‹åºæä¾›è‚Œè‚¤åˆ†æã€äº§å“åˆ†æã€æˆåˆ†å†²çªæ£€æµ‹ç­‰åŠŸèƒ½ï¼Œæ‰€æœ‰APIå‡åŸºäºRESTfulæ¶æ„è®¾è®¡ï¼Œè¿”å›JSONæ ¼å¼æ•°æ®ã€‚

## åŸºç¡€ä¿¡æ¯

- åŸºç¡€URL: `https://api.ai-skincare.com/v1`
- è®¤è¯æ–¹å¼: Bearer Token (JWT)
- æ‰€æœ‰è¯·æ±‚å¤´éœ€åŒ…å« `Content-Type: application/json`
- æ‰€æœ‰è¯·æ±‚å¤´éœ€åŒ…å« `Authorization: Bearer {token}`ï¼ˆé™¤ç™»å½•/æ³¨å†Œæ¥å£å¤–ï¼‰

## é”™è¯¯å¤„ç†

æ‰€æœ‰APIéµå¾ªç»Ÿä¸€çš„é”™è¯¯å“åº”æ ¼å¼ï¼š

```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "é”™è¯¯æè¿°ä¿¡æ¯"
  }
}
```

å¸¸è§é”™è¯¯ç ï¼š
- `AUTHENTICATION_ERROR`: è®¤è¯å¤±è´¥
- `PERMISSION_DENIED`: æƒé™ä¸è¶³
- `RESOURCE_NOT_FOUND`: èµ„æºä¸å­˜åœ¨
- `VALIDATION_ERROR`: è¯·æ±‚å‚æ•°éªŒè¯å¤±è´¥
- `SERVER_ERROR`: æœåŠ¡å™¨å†…éƒ¨é”™è¯¯

## API ç«¯ç‚¹

### 1. ç”¨æˆ·è®¤è¯

#### 1.1 ç”¨æˆ·æ³¨å†Œ

- **URL**: `/auth/register`
- **æ–¹æ³•**: `POST`
- **æè¿°**: æ³¨å†Œæ–°ç”¨æˆ·
- **è¯·æ±‚ä½“**:
```json
{
  "username": "ç”¨æˆ·å",
  "email": "é‚®ç®±åœ°å€",
  "password": "å¯†ç ",
  "phoneNumber": "æ‰‹æœºå·ç "
}
```
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "user": {
      "id": "ç”¨æˆ·ID",
      "username": "ç”¨æˆ·å",
      "email": "é‚®ç®±åœ°å€",
      "avatarUrl": "å¤´åƒURL",
      "createdAt": "åˆ›å»ºæ—¶é—´"
    },
    "token": "JWTä»¤ç‰Œ"
  }
}
```

#### 1.2 ç”¨æˆ·ç™»å½•

- **URL**: `/auth/login`
- **æ–¹æ³•**: `POST`
- **æè¿°**: ç”¨æˆ·ç™»å½•å¹¶è·å–è®¤è¯ä»¤ç‰Œ
- **è¯·æ±‚ä½“**:
```json
{
  "email": "é‚®ç®±åœ°å€",
  "password": "å¯†ç "
}
```
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "user": {
      "id": "ç”¨æˆ·ID",
      "username": "ç”¨æˆ·å",
      "email": "é‚®ç®±åœ°å€",
      "avatarUrl": "å¤´åƒURL",
      "lastLoginAt": "æœ€åç™»å½•æ—¶é—´"
    },
    "token": "JWTä»¤ç‰Œ"
  }
}
```

### 2. ç”¨æˆ·ä¿¡æ¯

#### 2.1 è·å–ç”¨æˆ·ä¿¡æ¯

- **URL**: `/users/me`
- **æ–¹æ³•**: `GET`
- **æè¿°**: è·å–å½“å‰ç™»å½•ç”¨æˆ·çš„è¯¦ç»†ä¿¡æ¯
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "id": "ç”¨æˆ·ID",
    "username": "ç”¨æˆ·å",
    "email": "é‚®ç®±åœ°å€",
    "phoneNumber": "æ‰‹æœºå·ç ",
    "avatarUrl": "å¤´åƒURL",
    "skinType": "è‚Œè‚¤ç±»å‹",
    "concerns": ["å¹²ç‡¥", "æ•æ„Ÿ"],
    "favorites": ["äº§å“IDåˆ—è¡¨"],
    "createdAt": "åˆ›å»ºæ—¶é—´",
    "lastLoginAt": "æœ€åç™»å½•æ—¶é—´"
  }
}
```

#### 2.2 æ›´æ–°ç”¨æˆ·ä¿¡æ¯

- **URL**: `/users/me`
- **æ–¹æ³•**: `PUT`
- **æè¿°**: æ›´æ–°å½“å‰ç”¨æˆ·çš„ä¿¡æ¯
- **è¯·æ±‚ä½“**:
```json
{
  "username": "æ–°ç”¨æˆ·å",
  "avatarUrl": "æ–°å¤´åƒURL",
  "skinType": "æ–°è‚Œè‚¤ç±»å‹",
  "concerns": ["æ–°è‚Œè‚¤é—®é¢˜åˆ—è¡¨"]
}
```
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "id": "ç”¨æˆ·ID",
    "username": "æ›´æ–°åçš„ç”¨æˆ·å",
    "email": "é‚®ç®±åœ°å€",
    "avatarUrl": "æ›´æ–°åçš„å¤´åƒURL",
    "skinType": "æ›´æ–°åçš„è‚Œè‚¤ç±»å‹",
    "concerns": ["æ›´æ–°åçš„è‚Œè‚¤é—®é¢˜åˆ—è¡¨"],
    "updatedAt": "æ›´æ–°æ—¶é—´"
  }
}
```

### 3. è‚Œè‚¤åˆ†æ

#### 3.1 ä¸Šä¼ å›¾ç‰‡åˆ†æ

- **URL**: `/skin-analysis/detect`
- **æ–¹æ³•**: `POST`
- **æè¿°**: ä¸Šä¼ è‚Œè‚¤ç…§ç‰‡è¿›è¡ŒAIåˆ†æ
- **è¯·æ±‚ä½“**: 
  - `Content-Type: multipart/form-data`
  - `image`: å›¾ç‰‡æ–‡ä»¶
  - `quizData`: é—®å·æ•°æ®JSONå­—ç¬¦ä¸²ï¼ˆå¯é€‰ï¼‰
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "analysisId": "åˆ†æè®°å½•ID",
    "status": "completed",
    "results": {
      "hydration": {
        "value": 75,
        "status": "çš®è‚¤æ°´åˆ†å……è¶³ï¼Œç»§ç»­ä¿æŒå–µï½",
        "trend": "+5%",
        "trendUp": true
      },
      "oil": {
        "value": 60,
        "status": "TåŒºæ²¹åˆ†ç•¥åé«˜ï¼Œå»ºè®®ä½¿ç”¨æ§æ²¹äº§å“å–µï½"
      },
      "sensitivity": {
        "value": 2,
        "maxValue": 5,
        "status": "è½»åº¦æ•æ„Ÿï¼Œå»ºè®®ä½¿ç”¨æ¸©å’Œäº§å“å–µï½"
      },
      "pores": {
        "value": 30,
        "status": "æ¯›å­”çŠ¶å†µè‰¯å¥½"
      },
      "wrinkles": {
        "value": 15,
        "status": "å‡ ä¹æ— ç»†çº¹"
      },
      "pigmentation": {
        "value": 25,
        "status": "è½»å¾®è‰²ç´ æ²‰ç€"
      }
    },
    "recommendations": [
      {
        "id": "æ¨èID",
        "title": "åŠ å¼ºä¿æ¹¿é˜²æŠ¤",
        "description": "å»ºè®®ä½¿ç”¨å«ç»å°¿é…¸çš„ä¿æ¹¿ç²¾åï¼Œæå‡è‚Œè‚¤æ°´æ¶¦åº¦",
        "iconType": "shield",
        "priority": "é«˜",
        "timing": "å»ºè®®ç«‹å³ä½¿ç”¨",
        "recommendedProducts": ["äº§å“IDåˆ—è¡¨"]
      },
      {
        "id": "æ¨èID",
        "title": "é˜²æ™’æé†’",
        "description": "ä»Šæ—¥ç´«å¤–çº¿è¾ƒå¼ºï¼Œè®°å¾—æ¶‚é˜²æ™’å–µï½",
        "iconType": "sun",
        "priority": "ä¸­",
        "timing": "å¤–å‡ºå‰ä½¿ç”¨"
      }
    ],
    "createdAt": "åˆ›å»ºæ—¶é—´"
  }
}
```

#### 3.2 è·å–åˆ†æå†å²

- **URL**: `/skin-analysis/history`
- **æ–¹æ³•**: `GET`
- **æè¿°**: è·å–ç”¨æˆ·çš„è‚Œè‚¤åˆ†æå†å²è®°å½•
- **è¯·æ±‚å‚æ•°**:
  - `page`: é¡µç ï¼ˆé»˜è®¤1ï¼‰
  - `limit`: æ¯é¡µæ•°é‡ï¼ˆé»˜è®¤10ï¼‰
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "total": æ€»è®°å½•æ•°,
    "pages": æ€»é¡µæ•°,
    "current": å½“å‰é¡µç ,
    "records": [
      {
        "id": "åˆ†æè®°å½•ID",
        "thumbnailUrl": "åˆ†æå›¾ç‰‡ç¼©ç•¥å›¾URL",
        "createdAt": "åˆ›å»ºæ—¶é—´",
        "mainResults": {
          "hydration": 75,
          "oil": 60,
          "sensitivity": 2
        }
      }
    ]
  }
}
```

#### 3.3 è·å–å•æ¡åˆ†æè¯¦æƒ…

- **URL**: `/skin-analysis/{analysisId}`
- **æ–¹æ³•**: `GET`
- **æè¿°**: è·å–æŸæ¡è‚Œè‚¤åˆ†æçš„è¯¦ç»†ä¿¡æ¯
- **è¯·æ±‚å‚æ•°**:
  - `analysisId`: åˆ†æè®°å½•ID
- **å“åº”**: ä¸3.1å“åº”æ ¼å¼ç›¸åŒ

### 4. äº§å“åˆ†æ

#### 4.1 æ‰«æäº§å“

- **URL**: `/product-analysis/scan`
- **æ–¹æ³•**: `POST`
- **æè¿°**: ä¸Šä¼ äº§å“å›¾ç‰‡è¿›è¡Œè¯†åˆ«å’Œåˆ†æ
- **è¯·æ±‚ä½“**: 
  - `Content-Type: multipart/form-data`
  - `image`: äº§å“å›¾ç‰‡æ–‡ä»¶
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "analysisId": "åˆ†æè®°å½•ID",
    "status": "completed",
    "product": {
      "id": "äº§å“ID",
      "name": "äº§å“åç§°",
      "brand": "å“ç‰Œåç§°",
      "category": "äº§å“ç±»åˆ«",
      "imageUrl": "äº§å“å›¾ç‰‡URL",
      "description": "äº§å“æè¿°"
    },
    "ingredients": [
      {
        "id": "æˆåˆ†ID",
        "name": "æˆåˆ†åç§°",
        "function": "æˆåˆ†åŠŸæ•ˆ",
        "safetyLevel": 1,
        "irritationRisk": "ä½",
        "acneRisk": "ä½",
        "description": "æˆåˆ†æè¿°"
      }
    ],
    "analysis": {
      "safetyScore": 85,
      "effectivenessScore": 90,
      "suitabilityScore": 75,
      "highlights": [
        {
          "type": "good",
          "description": "å«æœ‰å¤šç§ä¿æ¹¿æˆåˆ†ï¼Œé€‚åˆå¹²æ€§è‚Œè‚¤"
        },
        {
          "type": "warning",
          "description": "å«æœ‰é…’ç²¾ï¼Œå¯èƒ½å¯¹æ•æ„Ÿè‚Œä¸å‹å¥½"
        }
      ]
    },
    "createdAt": "åˆ›å»ºæ—¶é—´"
  }
}
```

#### 4.2 æœç´¢äº§å“

- **URL**: `/products/search`
- **æ–¹æ³•**: `GET`
- **æè¿°**: æœç´¢äº§å“æ•°æ®åº“
- **è¯·æ±‚å‚æ•°**:
  - `query`: æœç´¢å…³é”®è¯
  - `category`: äº§å“ç±»åˆ«ï¼ˆå¯é€‰ï¼‰
  - `brand`: å“ç‰Œï¼ˆå¯é€‰ï¼‰
  - `page`: é¡µç ï¼ˆé»˜è®¤1ï¼‰
  - `limit`: æ¯é¡µæ•°é‡ï¼ˆé»˜è®¤10ï¼‰
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "total": æ€»è®°å½•æ•°,
    "pages": æ€»é¡µæ•°,
    "current": å½“å‰é¡µç ,
    "records": [
      {
        "id": "äº§å“ID",
        "name": "äº§å“åç§°",
        "brand": "å“ç‰Œåç§°",
        "category": "äº§å“ç±»åˆ«",
        "imageUrl": "äº§å“å›¾ç‰‡URL",
        "rating": 4.5,
        "reviewCount": 120
      }
    ]
  }
}
```

#### 4.3 è·å–äº§å“è¯¦æƒ…

- **URL**: `/products/{productId}`
- **æ–¹æ³•**: `GET`
- **æè¿°**: è·å–äº§å“è¯¦ç»†ä¿¡æ¯
- **è¯·æ±‚å‚æ•°**:
  - `productId`: äº§å“ID
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "id": "äº§å“ID",
    "name": "äº§å“åç§°",
    "brand": "å“ç‰Œåç§°",
    "category": "äº§å“ç±»åˆ«",
    "subCategory": "äº§å“å­ç±»åˆ«",
    "imageUrl": "äº§å“å›¾ç‰‡URL",
    "description": "äº§å“æè¿°",
    "price": 299.00,
    "currency": "CNY",
    "size": "50ml",
    "rating": 4.5,
    "reviewCount": 120,
    "ingredients": [
      {
        "id": "æˆåˆ†ID",
        "name": "æˆåˆ†åç§°",
        "function": "æˆåˆ†åŠŸæ•ˆ",
        "safetyLevel": 1,
        "irritationRisk": "ä½",
        "acneRisk": "ä½"
      }
    ],
    "analysis": {
      "safetyScore": 85,
      "effectivenessScore": 90,
      "suitabilityScore": 75,
      "goodFor": ["å¹²æ€§è‚Œè‚¤", "ç¼ºæ°´è‚Œè‚¤"],
      "notRecommendedFor": ["æ²¹æ€§è‚Œè‚¤"]
    },
    "reviews": [
      {
        "id": "è¯„è®ºID",
        "userId": "ç”¨æˆ·ID",
        "username": "ç”¨æˆ·å",
        "rating": 5,
        "content": "è¯„è®ºå†…å®¹",
        "createdAt": "è¯„è®ºæ—¶é—´"
      }
    ]
  }
}
```

### 5. æˆåˆ†åˆ†æ

#### 5.1 æˆåˆ†è¯¦æƒ…

- **URL**: `/ingredients/{ingredientId}`
- **æ–¹æ³•**: `GET`
- **æè¿°**: è·å–æˆåˆ†è¯¦ç»†ä¿¡æ¯
- **è¯·æ±‚å‚æ•°**:
  - `ingredientId`: æˆåˆ†ID
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "id": "æˆåˆ†ID",
    "name": "æˆåˆ†åç§°",
    "alias": ["åˆ«å1", "åˆ«å2"],
    "engName": "è‹±æ–‡åç§°",
    "casNumber": "CASå·",
    "category": "æˆåˆ†ç±»åˆ«",
    "function": "ä¸»è¦åŠŸæ•ˆ",
    "description": "è¯¦ç»†æè¿°",
    "safetyLevel": 1,
    "safetyDescription": "å®‰å…¨ç­‰çº§æè¿°",
    "irritationRisk": "ä½",
    "acneRisk": "ä½",
    "allergicRisk": "ä½",
    "pregnancySafe": true,
    "researchPapers": ["ç ”ç©¶è®ºæ–‡å¼•ç”¨"],
    "suitableSkinTypes": ["é€‚åˆçš„è‚Œè‚¤ç±»å‹"],
    "notSuitableSkinTypes": ["ä¸é€‚åˆçš„è‚Œè‚¤ç±»å‹"],
    "commonProducts": [
      {
        "id": "äº§å“ID",
        "name": "äº§å“åç§°",
        "brand": "å“ç‰Œåç§°",
        "imageUrl": "äº§å“å›¾ç‰‡URL"
      }
    ]
  }
}
```

#### 5.2 æˆåˆ†æœç´¢

- **URL**: `/ingredients/search`
- **æ–¹æ³•**: `GET`
- **æè¿°**: æœç´¢æˆåˆ†æ•°æ®åº“
- **è¯·æ±‚å‚æ•°**:
  - `query`: æœç´¢å…³é”®è¯
  - `category`: æˆåˆ†ç±»åˆ«ï¼ˆå¯é€‰ï¼‰
  - `function`: æˆåˆ†åŠŸæ•ˆï¼ˆå¯é€‰ï¼‰
  - `page`: é¡µç ï¼ˆé»˜è®¤1ï¼‰
  - `limit`: æ¯é¡µæ•°é‡ï¼ˆé»˜è®¤10ï¼‰
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "total": æ€»è®°å½•æ•°,
    "pages": æ€»é¡µæ•°,
    "current": å½“å‰é¡µç ,
    "records": [
      {
        "id": "æˆåˆ†ID",
        "name": "æˆåˆ†åç§°",
        "engName": "è‹±æ–‡åç§°",
        "function": "ä¸»è¦åŠŸæ•ˆ",
        "safetyLevel": 1,
        "irritationRisk": "ä½"
      }
    ]
  }
}
```

### 6. æˆåˆ†å†²çªæ£€æµ‹

#### 6.1 æ£€æµ‹æˆåˆ†å†²çª

- **URL**: `/conflict-detection/check`
- **æ–¹æ³•**: `POST`
- **æè¿°**: æ£€æµ‹å¤šä¸ªæˆåˆ†ä¹‹é—´å¯èƒ½å­˜åœ¨çš„å†²çª
- **è¯·æ±‚ä½“**:
```json
{
  "ingredientIds": ["æˆåˆ†IDåˆ—è¡¨"]
}
```
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "conflicts": [
      {
        "ingredientPair": [
          {
            "id": "æˆåˆ†1ID",
            "name": "æˆåˆ†1åç§°"
          },
          {
            "id": "æˆåˆ†2ID",
            "name": "æˆåˆ†2åç§°"
          }
        ],
        "level": "severe",
        "description": "è¿™ä¸¤ç§æˆåˆ†ä¸åº”åŒæ—¶ä½¿ç”¨ï¼Œå¯èƒ½å¯¼è‡´è‚Œè‚¤åˆºæ¿€",
        "recommendations": [
          "å»ºè®®åœ¨ä¸åŒçš„æŠ¤è‚¤æ­¥éª¤ä¸­ä½¿ç”¨",
          "è‡³å°‘é—´éš”30åˆ†é’Ÿä½¿ç”¨"
        ]
      }
    ],
    "compatibleGroups": [
      ["å…¼å®¹æˆåˆ†ç»„åˆ"]
    ],
    "usageSuggestion": "å»ºè®®ä½¿ç”¨é¡ºåºå’Œæ–¹æ³•"
  }
}
```

#### 6.2 æ£€æµ‹äº§å“å†²çª

- **URL**: `/conflict-detection/products`
- **æ–¹æ³•**: `POST`
- **æè¿°**: æ£€æµ‹å¤šä¸ªäº§å“ä¹‹é—´å¯èƒ½å­˜åœ¨çš„æˆåˆ†å†²çª
- **è¯·æ±‚ä½“**:
```json
{
  "productIds": ["äº§å“IDåˆ—è¡¨"]
}
```
- **å“åº”**: ä¸6.1ç±»ä¼¼ï¼Œä½†åŒ…å«äº§å“ä¿¡æ¯

### 7. æŠ¤è‚¤æ—¥è®°

#### 7.1 åˆ›å»ºæŠ¤è‚¤æ—¥è®°

- **URL**: `/skincare-diary`
- **æ–¹æ³•**: `POST`
- **æè¿°**: åˆ›å»ºä¸€æ¡æŠ¤è‚¤æ—¥è®°è®°å½•
- **è¯·æ±‚ä½“**:
```json
{
  "date": "æ—¥æœŸ",
  "skinCondition": "è‚Œè‚¤çŠ¶å†µ",
  "products": [
    {
      "productId": "äº§å“ID",
      "usageTime": "ä½¿ç”¨æ—¶é—´",
      "step": "æŠ¤è‚¤æ­¥éª¤",
      "notes": "ä½¿ç”¨å¤‡æ³¨"
    }
  ],
  "notes": "æ•´ä½“å¤‡æ³¨",
  "images": ["å›¾ç‰‡URLæ•°ç»„"],
  "mood": "å¿ƒæƒ…",
  "weather": "å¤©æ°”"
}
```
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "id": "æ—¥è®°ID",
    "date": "æ—¥æœŸ",
    "skinCondition": "è‚Œè‚¤çŠ¶å†µ",
    "products": [
      {
        "product": {
          "id": "äº§å“ID",
          "name": "äº§å“åç§°",
          "brand": "å“ç‰Œåç§°",
          "imageUrl": "äº§å“å›¾ç‰‡URL"
        },
        "usageTime": "ä½¿ç”¨æ—¶é—´",
        "step": "æŠ¤è‚¤æ­¥éª¤",
        "notes": "ä½¿ç”¨å¤‡æ³¨"
      }
    ],
    "notes": "æ•´ä½“å¤‡æ³¨",
    "images": ["å›¾ç‰‡URLæ•°ç»„"],
    "mood": "å¿ƒæƒ…",
    "weather": "å¤©æ°”",
    "createdAt": "åˆ›å»ºæ—¶é—´"
  }
}
```

#### 7.2 è·å–æŠ¤è‚¤æ—¥è®°åˆ—è¡¨

- **URL**: `/skincare-diary`
- **æ–¹æ³•**: `GET`
- **æè¿°**: è·å–ç”¨æˆ·çš„æŠ¤è‚¤æ—¥è®°åˆ—è¡¨
- **è¯·æ±‚å‚æ•°**:
  - `month`: æœˆä»½ï¼ˆæ ¼å¼ï¼šYYYY-MMï¼Œå¯é€‰ï¼‰
  - `page`: é¡µç ï¼ˆé»˜è®¤1ï¼‰
  - `limit`: æ¯é¡µæ•°é‡ï¼ˆé»˜è®¤10ï¼‰
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "total": æ€»è®°å½•æ•°,
    "pages": æ€»é¡µæ•°,
    "current": å½“å‰é¡µç ,
    "records": [
      {
        "id": "æ—¥è®°ID",
        "date": "æ—¥æœŸ",
        "skinCondition": "è‚Œè‚¤çŠ¶å†µ",
        "productCount": äº§å“æ•°é‡,
        "hasImages": true/false,
        "mood": "å¿ƒæƒ…",
        "createdAt": "åˆ›å»ºæ—¶é—´"
      }
    ]
  }
}
```

### 8. æ–‡ç« å’Œèµ„è®¯

#### 8.1 è·å–æ–‡ç« åˆ—è¡¨

- **URL**: `/articles`
- **æ–¹æ³•**: `GET`
- **æè¿°**: è·å–æŠ¤è‚¤çŸ¥è¯†æ–‡ç« åˆ—è¡¨
- **è¯·æ±‚å‚æ•°**:
  - `category`: æ–‡ç« ç±»åˆ«ï¼ˆå¯é€‰ï¼‰
  - `tag`: æ–‡ç« æ ‡ç­¾ï¼ˆå¯é€‰ï¼‰
  - `page`: é¡µç ï¼ˆé»˜è®¤1ï¼‰
  - `limit`: æ¯é¡µæ•°é‡ï¼ˆé»˜è®¤10ï¼‰
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "total": æ€»è®°å½•æ•°,
    "pages": æ€»é¡µæ•°,
    "current": å½“å‰é¡µç ,
    "records": [
      {
        "id": "æ–‡ç« ID",
        "title": "æ–‡ç« æ ‡é¢˜",
        "summary": "æ–‡ç« æ‘˜è¦",
        "author": "ä½œè€…",
        "category": "æ–‡ç« ç±»åˆ«",
        "tags": ["æ ‡ç­¾1", "æ ‡ç­¾2"],
        "coverImageUrl": "å°é¢å›¾ç‰‡URL",
        "publishedAt": "å‘å¸ƒæ—¶é—´",
        "readCount": é˜…è¯»é‡
      }
    ]
  }
}
```

#### 8.2 è·å–æ–‡ç« è¯¦æƒ…

- **URL**: `/articles/{articleId}`
- **æ–¹æ³•**: `GET`
- **æè¿°**: è·å–æ–‡ç« è¯¦ç»†å†…å®¹
- **è¯·æ±‚å‚æ•°**:
  - `articleId`: æ–‡ç« ID
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "id": "æ–‡ç« ID",
    "title": "æ–‡ç« æ ‡é¢˜",
    "content": "æ–‡ç« å†…å®¹ï¼ˆHTMLæ ¼å¼ï¼‰",
    "author": {
      "id": "ä½œè€…ID",
      "name": "ä½œè€…åç§°",
      "avatarUrl": "ä½œè€…å¤´åƒURL",
      "title": "ä½œè€…å¤´è¡”"
    },
    "category": "æ–‡ç« ç±»åˆ«",
    "tags": ["æ ‡ç­¾1", "æ ‡ç­¾2"],
    "coverImageUrl": "å°é¢å›¾ç‰‡URL",
    "images": ["æ–‡ç« å›¾ç‰‡URLæ•°ç»„"],
    "publishedAt": "å‘å¸ƒæ—¶é—´",
    "readCount": é˜…è¯»é‡,
    "relatedArticles": [
      {
        "id": "ç›¸å…³æ–‡ç« ID",
        "title": "ç›¸å…³æ–‡ç« æ ‡é¢˜",
        "coverImageUrl": "å°é¢å›¾ç‰‡URL"
      }
    ],
    "relatedProducts": [
      {
        "id": "ç›¸å…³äº§å“ID",
        "name": "ç›¸å…³äº§å“åç§°",
        "imageUrl": "äº§å“å›¾ç‰‡URL"
      }
    ]
  }
}
```

### 9. å¤©æ°”ä¸æŠ¤è‚¤å»ºè®®

#### 9.1 è·å–å½“å‰ä½ç½®å¤©æ°”å’ŒæŠ¤è‚¤å»ºè®®

- **URL**: `/weather-advice`
- **æ–¹æ³•**: `GET`
- **æè¿°**: æ ¹æ®ç”¨æˆ·ä½ç½®è·å–å¤©æ°”ä¿¡æ¯å’Œç›¸åº”çš„æŠ¤è‚¤å»ºè®®
- **è¯·æ±‚å‚æ•°**:
  - `latitude`: çº¬åº¦ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä½¿ç”¨ä¸Šæ¬¡ä½ç½®ï¼‰
  - `longitude`: ç»åº¦ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä½¿ç”¨ä¸Šæ¬¡ä½ç½®ï¼‰
- **å“åº”**:
```json
{
  "success": true,
  "data": {
    "location": {
      "city": "åŸå¸‚åç§°",
      "district": "åŒºåŸŸåç§°"
    },
    "weather": {
      "condition": "æ™´",
      "temperature": 26,
      "humidity": 60,
      "windSpeed": 3.4,
      "uvIndex": 7,
      "pm25": 35,
      "airQuality": "è‰¯å¥½"
    },
    "advice": {
      "summary": "ä»Šæ—¥ç´«å¤–çº¿è¾ƒå¼ºï¼Œæ³¨æ„é˜²æ™’",
      "detail": "è¯¦ç»†å»ºè®®å†…å®¹",
      "emphasisPoints": [
        {
          "title": "é˜²æ™’",
          "description": "å»ºè®®ä½¿ç”¨SPF50+é˜²æ™’éœœ"
        },
        {
          "title": "è¡¥æ°´",
          "description": "éšèº«æºå¸¦å–·é›¾è¡¥æ°´"
        }
      ],
      "recommendedProducts": [
        {
          "id": "äº§å“ID",
          "name": "äº§å“åç§°",
          "brand": "å“ç‰Œåç§°",
          "imageUrl": "äº§å“å›¾ç‰‡URL",
          "category": "äº§å“ç±»åˆ«"
        }
      ]
    }
  }
}
```

## æ•°æ®æ¨¡å‹

### ç”¨æˆ·æ¨¡å‹ (User)

```json
{
  "id": "ç”¨æˆ·ID",
  "username": "ç”¨æˆ·å",
  "email": "é‚®ç®±åœ°å€",
  "phoneNumber": "æ‰‹æœºå·ç ",
  "avatarUrl": "å¤´åƒURL",
  "password": "åŠ å¯†å¯†ç ï¼ˆä¸è¿”å›ç»™å®¢æˆ·ç«¯ï¼‰",
  "skinType": "è‚Œè‚¤ç±»å‹",
  "concerns": ["è‚Œè‚¤é—®é¢˜åˆ—è¡¨"],
  "favorites": ["æ”¶è—çš„äº§å“IDåˆ—è¡¨"],
  "createdAt": "åˆ›å»ºæ—¶é—´",
  "updatedAt": "æ›´æ–°æ—¶é—´",
  "lastLoginAt": "æœ€åç™»å½•æ—¶é—´"
}
```

### è‚Œè‚¤åˆ†æè®°å½•æ¨¡å‹ (SkinAnalysis)

```json
{
  "id": "åˆ†æè®°å½•ID",
  "userId": "ç”¨æˆ·ID",
  "imageUrl": "åŸå§‹å›¾ç‰‡URL",
  "thumbnailUrl": "ç¼©ç•¥å›¾URL",
  "quizData": {
    "skinType": "é—®å·å›ç­”çš„è‚Œè‚¤ç±»å‹",
    "concerns": ["é—®å·å›ç­”çš„è‚Œè‚¤é—®é¢˜"],
    "sensitivity": "é—®å·å›ç­”çš„æ•æ„Ÿç¨‹åº¦"
  },
  "results": {
    "hydration": { "value": 75, "status": "çŠ¶æ€æè¿°", "trend": "+5%", "trendUp": true },
    "oil": { "value": 60, "status": "çŠ¶æ€æè¿°" },
    "sensitivity": { "value": 2, "maxValue": 5, "status": "çŠ¶æ€æè¿°" },
    "pores": { "value": 30, "status": "çŠ¶æ€æè¿°" },
    "wrinkles": { "value": 15, "status": "çŠ¶æ€æè¿°" },
    "pigmentation": { "value": 25, "status": "çŠ¶æ€æè¿°" }
  },
  "recommendations": [
    {
      "id": "æ¨èID",
      "title": "æ¨èæ ‡é¢˜",
      "description": "æ¨èæè¿°",
      "iconType": "å›¾æ ‡ç±»å‹",
      "priority": "ä¼˜å…ˆçº§",
      "timing": "ä½¿ç”¨æ—¶æœº",
      "recommendedProducts": ["æ¨èäº§å“IDåˆ—è¡¨"]
    }
  ],
  "createdAt": "åˆ›å»ºæ—¶é—´"
}
```

### äº§å“æ¨¡å‹ (Product)

```json
{
  "id": "äº§å“ID",
  "name": "äº§å“åç§°",
  "brand": "å“ç‰Œåç§°",
  "category": "äº§å“ç±»åˆ«",
  "subCategory": "äº§å“å­ç±»åˆ«",
  "imageUrl": "äº§å“å›¾ç‰‡URL",
  "description": "äº§å“æè¿°",
  "price": 299.00,
  "currency": "CNY",
  "size": "50ml",
  "ingredients": ["æˆåˆ†IDåˆ—è¡¨"],
  "rating": 4.5,
  "reviewCount": 120,
  "analysis": {
    "safetyScore": 85,
    "effectivenessScore": 90,
    "suitabilityScore": 75,
    "goodFor": ["é€‚åˆçš„è‚Œè‚¤ç±»å‹"],
    "notRecommendedFor": ["ä¸æ¨èçš„è‚Œè‚¤ç±»å‹"]
  },
  "createdAt": "åˆ›å»ºæ—¶é—´",
  "updatedAt": "æ›´æ–°æ—¶é—´"
}
```

### æˆåˆ†æ¨¡å‹ (Ingredient)

```json
{
  "id": "æˆåˆ†ID",
  "name": "æˆåˆ†åç§°",
  "alias": ["åˆ«ååˆ—è¡¨"],
  "engName": "è‹±æ–‡åç§°",
  "casNumber": "CASå·",
  "category": "æˆåˆ†ç±»åˆ«",
  "function": "ä¸»è¦åŠŸæ•ˆ",
  "description": "è¯¦ç»†æè¿°",
  "safetyLevel": 1,
  "safetyDescription": "å®‰å…¨ç­‰çº§æè¿°",
  "irritationRisk": "åˆºæ¿€é£é™©",
  "acneRisk": "ç—˜ç—˜é£é™©",
  "allergicRisk": "è¿‡æ•é£é™©",
  "pregnancySafe": true,
  "researchPapers": ["ç ”ç©¶è®ºæ–‡å¼•ç”¨"],
  "suitableSkinTypes": ["é€‚åˆçš„è‚Œè‚¤ç±»å‹"],
  "notSuitableSkinTypes": ["ä¸é€‚åˆçš„è‚Œè‚¤ç±»å‹"],
  "createdAt": "åˆ›å»ºæ—¶é—´",
  "updatedAt": "æ›´æ–°æ—¶é—´"
}
```

### æˆåˆ†å†²çªæ¨¡å‹ (IngredientConflict)

```json
{
  "id": "å†²çªID",
  "ingredientPair": ["æˆåˆ†IDå¯¹"],
  "level": "å†²çªç­‰çº§",
  "description": "å†²çªæè¿°",
  "recommendations": ["å»ºè®®åˆ—è¡¨"],
  "source": "æ•°æ®æ¥æº",
  "createdAt": "åˆ›å»ºæ—¶é—´",
  "updatedAt": "æ›´æ–°æ—¶é—´"
}
```

### æŠ¤è‚¤æ—¥è®°æ¨¡å‹ (SkincareDiary)

```json
{
  "id": "æ—¥è®°ID",
  "userId": "ç”¨æˆ·ID",
  "date": "æ—¥æœŸ",
  "skinCondition": "è‚Œè‚¤çŠ¶å†µ",
  "products": [
    {
      "productId": "äº§å“ID",
      "usageTime": "ä½¿ç”¨æ—¶é—´",
      "step": "æŠ¤è‚¤æ­¥éª¤",
      "notes": "ä½¿ç”¨å¤‡æ³¨"
    }
  ],
  "notes": "æ•´ä½“å¤‡æ³¨",
  "images": ["å›¾ç‰‡URLæ•°ç»„"],
  "mood": "å¿ƒæƒ…",
  "weather": "å¤©æ°”",
  "createdAt": "åˆ›å»ºæ—¶é—´",
  "updatedAt": "æ›´æ–°æ—¶é—´"
}
```

### æ–‡ç« æ¨¡å‹ (Article)

```json
{
  "id": "æ–‡ç« ID",
  "title": "æ–‡ç« æ ‡é¢˜",
  "summary": "æ–‡ç« æ‘˜è¦",
  "content": "æ–‡ç« å†…å®¹ï¼ˆHTMLæ ¼å¼ï¼‰",
  "authorId": "ä½œè€…ID",
  "category": "æ–‡ç« ç±»åˆ«",
  "tags": ["æ ‡ç­¾åˆ—è¡¨"],
  "coverImageUrl": "å°é¢å›¾ç‰‡URL",
  "images": ["æ–‡ç« å›¾ç‰‡URLæ•°ç»„"],
  "publishedAt": "å‘å¸ƒæ—¶é—´",
  "readCount": é˜…è¯»é‡,
  "relatedArticles": ["ç›¸å…³æ–‡ç« IDåˆ—è¡¨"],
  "relatedProducts": ["ç›¸å…³äº§å“IDåˆ—è¡¨"],
  "createdAt": "åˆ›å»ºæ—¶é—´",
  "updatedAt": "æ›´æ–°æ—¶é—´"
}
```

## å®‰å…¨ä¸æ€§èƒ½è€ƒè™‘

1. æ‰€æœ‰APIè¯·æ±‚ä½¿ç”¨HTTPSåŠ å¯†ä¼ è¾“
2. æ‰€æœ‰å¯†ç ä½¿ç”¨bcryptåŠ å¯†å­˜å‚¨
3. ç”¨æˆ·è®¤è¯é‡‡ç”¨JWTä»¤ç‰Œï¼Œæœ‰æ•ˆæœŸä¸º24å°æ—¶
4. é’ˆå¯¹å›¾ç‰‡ä¸Šä¼ æ¥å£ï¼Œé™åˆ¶æ–‡ä»¶å¤§å°ä¸è¶…è¿‡10MB
5. æ‰€æœ‰APIå‡å®ç°äº†é™æµä¿æŠ¤ï¼Œé»˜è®¤æ¯IPæ¯åˆ†é’Ÿä¸è¶…è¿‡60æ¬¡è¯·æ±‚
6. æ•æ„Ÿæ•°æ®ï¼ˆå¦‚ç”¨æˆ·è‚Œè‚¤åˆ†æè®°å½•ï¼‰é‡‡ç”¨é¢å¤–åŠ å¯†å­˜å‚¨
7. å›¾ç‰‡åˆ†æç»“æœç¼“å­˜24å°æ—¶ï¼Œå‡å°‘é‡å¤åˆ†æ
8. é’ˆå¯¹çƒ­é—¨äº§å“å’Œæˆåˆ†ä¿¡æ¯è¿›è¡ŒCDNç¼“å­˜ï¼Œæå‡å“åº”é€Ÿåº¦
```

```dart:ai_skincare/lib/models/skin_analysis_model.dart
class SkinAnalysisModel {
  final String id;
  final String userId;
  final String? imageUrl;
  final String? thumbnailUrl;
  final Map<String, dynamic> quizData;
  final Map<String, dynamic> results;
  final List<RecommendationModel> recommendations;
  final String createdAt;

  SkinAnalysisModel({
    required this.id,
    required this.userId,
    this.imageUrl,
    this.thumbnailUrl,
    required this.quizData,
    required this.results,
    required this.recommendations,
    required this.createdAt,
  });

  factory SkinAnalysisModel.fromJson(Map<String, dynamic> json) {
    List<RecommendationModel> recommendations = [];
    if (json['recommendations'] != null) {
      recommendations = List<RecommendationModel>.from(
        json['recommendations'].map((x) => RecommendationModel.fromJson(x)),
      );
    }

    return SkinAnalysisModel(
      id: json['id'],
      userId: json['userId'],
      imageUrl: json['imageUrl'],
      thumbnailUrl: json['thumbnailUrl'],
      quizData: json['quizData'] ?? {},
      results: json['results'] ?? {},
      recommendations: recommendations,
      createdAt: json['createdAt'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'userId': userId,
      'imageUrl': imageUrl,
      'thumbnailUrl': thumbnailUrl,
      'quizData': quizData,
      'results': results,
      'recommendations': recommendations.map((x) => x.toJson()).toList(),
      'createdAt': createdAt,
    };
  }
}

class RecommendationModel {
  final String id;
  final String title;
  final String description;
  final String iconType;
  final String priority;
  final String? timing;
  final List<String>? recommendedProducts;

  RecommendationModel({
    required this.id,
    required this.title,
    required this.description,
    required this.iconType,
    required this.priority,
    this.timing,
    this.recommendedProducts,
  });

  factory RecommendationModel.fromJson(Map<String, dynamic> json) {
    return RecommendationModel(
      id: json['id'],
      title: json['title'],
      description: json['description'],
      iconType: json['iconType'],
      priority: json['priority'],
      timing: json['timing'],
      recommendedProducts: json['recommendedProducts'] != null
          ? List<String>.from(json['recommendedProducts'])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'iconType': iconType,
      'priority': priority,
      'timing': timing,
      'recommendedProducts': recommendedProducts,
    };
  }
}
```

```dart:ai_skincare/lib/models/product_model.dart
class ProductModel {
  final String id;
  final String name;
  final String brand;
  final String category;
  final String? subCategory;
  final String? imageUrl;
  final String? description;
  final double? price;
  final String? currency;
  final String? size;
  final double? rating;
  final int? reviewCount;
  final List<IngredientModel>? ingredients;
  final ProductAnalysisModel? analysis;
  final String createdAt;
  final String updatedAt;

  ProductModel({
    required this.id,
    required this.name,
    required this.brand,
    required this.category,
    this.subCategory,
    this.imageUrl,
    this.description,
    this.price,
    this.currency,
    this.size,
    this.rating,
    this.reviewCount,
    this.ingredients,
    this.analysis,
    required this.createdAt,
    required this.updatedAt,
  });

  factory ProductModel.fromJson(Map<String, dynamic> json) {
    List<IngredientModel>? ingredients;
    if (json['ingredients'] != null) {
      ingredients = List<IngredientModel>.from(
        json['ingredients'].map((x) => IngredientModel.fromJson(x)),
      );
    }

    return ProductModel(
      id: json['id'],
      name: json['name'],
      brand: json['brand'],
      category: json['category'],
      subCategory: json['subCategory'],
      imageUrl: json['imageUrl'],
      description: json['description'],
      price: json['price']?.toDouble(),
      currency: json['currency'],
      size: json['size'],
      rating: json['rating']?.toDouble(),
      reviewCount: json['reviewCount'],
      ingredients: ingredients,
      analysis: json['analysis'] != null
          ? ProductAnalysisModel.fromJson(json['analysis'])
          : null,
      createdAt: json['createdAt'],
      updatedAt: json['updatedAt'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'brand': brand,
      'category': category,
      'subCategory': subCategory,
      'imageUrl': imageUrl,
      'description': description,
      'price': price,
      'currency': currency,
      'size': size,
      'rating': rating,
      'reviewCount': reviewCount,
      'ingredients': ingredients?.map((x) => x.toJson()).toList(),
      'analysis': analysis?.toJson(),
      'createdAt': createdAt,
      'updatedAt': updatedAt,
    };
  }
}

class ProductAnalysisModel {
  final int safetyScore;
  final int effectivenessScore;
  final int suitabilityScore;
  final List<String>? goodFor;
  final List<String>? notRecommendedFor;
  final List<HighlightModel>? highlights;

  ProductAnalysisModel({
    required this.safetyScore,
    required this.effectivenessScore,
    required this.suitabilityScore,
    this.goodFor,
    this.notRecommendedFor,
    this.highlights,
  });

  factory ProductAnalysisModel.fromJson(Map<String, dynamic> json) {
    List<HighlightModel>? highlights;
    if (json['highlights'] != null) {
      highlights = List<HighlightModel>.from(
        json['highlights'].map((x) => HighlightModel.fromJson(x)),
      );
    }

    return ProductAnalysisModel(
      safetyScore: json['safetyScore'],
      effectivenessScore: json['effectivenessScore'],
      suitabilityScore: json['suitabilityScore'],
      goodFor: json['goodFor'] != null
          ? List<String>.from(json['goodFor'])
          : null,
      notRecommendedFor: json['notRecommendedFor'] != null
          ? List<String>.from(json['notRecommendedFor'])
          : null,
      highlights: highlights,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'safetyScore': safetyScore,
      'effectivenessScore': effectivenessScore,
      'suitabilityScore': suitabilityScore,
      'goodFor': goodFor,
      'notRecommendedFor': notRecommendedFor,
      'highlights': highlights?.map((x) => x.toJson()).toList(),
    };
  }
}

class HighlightModel {
  final String type; // 'good' or 'warning'
  final String description;

  HighlightModel({
    required this.type,
    required this.description,
  });

  factory HighlightModel.fromJson(Map<String, dynamic> json) {
    return HighlightModel(
      type: json['type'],
      description: json['description'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'type': type,
      'description': description,
    };
  }
}
```

```dart:ai_skincare/lib/models/ingredient_model.dart
class IngredientModel {
  final String id;
  final String name;
  final List<String>? alias;
  final String? engName;
  final String? casNumber;
  final String? category;
  final String? function;
  final String? description;
  final int safetyLevel;
  final String? safetyDescription;
  final String irritationRisk;
  final String acneRisk;
  final String? allergicRisk;
  final bool? pregnancySafe;
  final List<String>? researchPapers;
  final List<String>? suitableSkinTypes;
  final List<String>? notSuitableSkinTypes;
  final String? createdAt;
  final String? updatedAt;

  IngredientModel({
    required this.id,
    required this.name,
    this.alias,
    this.engName,
    this.casNumber,
    this.category,
    this.function,
    this.description,
    required this.safetyLevel,
    this.safetyDescription,
    required this.irritationRisk,
    required this.acneRisk,
    this.allergicRisk,
    this.pregnancySafe,
    this.researchPapers,
    this.suitableSkinTypes,
    this.notSuitableSkinTypes,
    this.createdAt,
    this.updatedAt,
  });

  factory IngredientModel.fromJson(Map<String, dynamic> json) {
    return IngredientModel(
      id: json['id'],
      name: json['name'],
      alias: json['alias'] != null ? List<String>.from(json['alias']) : null,
      engName: json['engName'],
      casNumber: json['casNumber'],
      category: json['category'],
      function: json['function'],
      description: json['description'],
      safetyLevel: json['safetyLevel'],
      safetyDescription: json['safetyDescription'],
      irritationRisk: json['irritationRisk'],
      acneRisk: json['acneRisk'],
      allergicRisk: json['allergicRisk'],
      pregnancySafe: json['pregnancySafe'],
      researchPapers: json['researchPapers'] != null
          ? List<String>.from(json['researchPapers'])
          : null,
      suitableSkinTypes: json['suitableSkinTypes'] != null
          ? List<String>.from(json['suitableSkinTypes'])
          : null,
      notSuitableSkinTypes: json['notSuitableSkinTypes'] != null
          ? List<String>.from(json['notSuitableSkinTypes'])
          : null,
      createdAt: json['createdAt'],
      updatedAt: json['updatedAt'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'alias': alias,
      'engName': engName,
      'casNumber': casNumber,
      'category': category,
      'function': function,
      'description': description,
      'safetyLevel': safetyLevel,
      'safetyDescription': safetyDescription,
      'irritationRisk': irritationRisk,
      'acneRisk': acneRisk,
      'allergicRisk': allergicRisk,
      'pregnancySafe': pregnancySafe,
      'researchPapers': researchPapers,
      'suitableSkinTypes': suitableSkinTypes,
      'notSuitableSkinTypes': notSuitableSkinTypes,
      'createdAt': createdAt,
      'updatedAt': updatedAt,
    };
  }
}
```

```dart:ai_skincare/lib/models/product_model.dart
import 'ingredient_model.dart';

class ProductModel {
  final String id;
  final String name;
  final String brand;
  final String category;
  final String? subCategory;
  final String? imageUrl;
  final String? description;
  final double? price;
  final String? currency;
  final String? size;
  final double? rating;
  final int? reviewCount;
  final List<IngredientModel>? ingredients;
  final ProductAnalysisModel? analysis;
  final String createdAt;
  final String updatedAt;

  ProductModel({
    required this.id,
    required this.name,
    required this.brand,
    required this.category,
    this.subCategory,
    this.imageUrl,
    this.description,
    this.price,
    this.currency,
    this.size,
    this.rating,
    this.reviewCount,
    this.ingredients,
    this.analysis,
    required this.createdAt,
    required this.updatedAt,
  });

  factory ProductModel.fromJson(Map<String, dynamic> json) {
    List<IngredientModel>? ingredients;
    if (json['ingredients'] != null) {
      ingredients = List<IngredientModel>.from(
        json['ingredients'].map((x) => IngredientModel.fromJson(x)),
      );
    }

    return ProductModel(
      id: json['id'],
      name: json['name'],
      brand: json['brand'],
      category: json['category'],
      subCategory: json['subCategory'],
      imageUrl: json['imageUrl'],
      description: json['description'],
      price: json['price']?.toDouble(),
      currency: json['currency'],
      size: json['size'],
      rating: json['rating']?.toDouble(),
      reviewCount: json['reviewCount'],
      ingredients: ingredients,
      analysis: json['analysis'] != null
          ? ProductAnalysisModel.fromJson(json['analysis'])
          : null,
      createdAt: json['createdAt'],
      updatedAt: json['updatedAt'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'brand': brand,
      'category': category,
      'subCategory': subCategory,
      'imageUrl': imageUrl,
      'description': description,
      'price': price,
      'currency': currency,
      'size': size,
      'rating': rating,
      'reviewCount': reviewCount,
      'ingredients': ingredients?.map((x) => x.toJson()).toList(),
      'analysis': analysis?.toJson(),
      'createdAt': createdAt,
      'updatedAt': updatedAt,
    };
  }
}

class ProductAnalysisModel {
  final int safetyScore;
  final int effectivenessScore;
  final int suitabilityScore;
  final List<String>? goodFor;
  final List<String>? notRecommendedFor;
  final List<HighlightModel>? highlights;

  ProductAnalysisModel({
    required this.safetyScore,
    required this.effectivenessScore,
    required this.suitabilityScore,
    this.goodFor,
    this.notRecommendedFor,
    this.highlights,
  });

  factory ProductAnalysisModel.fromJson(Map<String, dynamic> json) {
    List<HighlightModel>? highlights;
    if (json['highlights'] != null) {
      highlights = List<HighlightModel>.from(
        json['highlights'].map((x) => HighlightModel.fromJson(x)),
      );
    }

    return ProductAnalysisModel(
      safetyScore: json['safetyScore'],
      effectivenessScore: json['effectivenessScore'],
      suitabilityScore: json['suitabilityScore'],
      goodFor: json['goodFor'] != null
          ? List<String>.from(json['goodFor'])
          : null,
      notRecommendedFor: json['notRecommendedFor'] != null
          ? List<String>.from(json['notRecommendedFor'])
          : null,
      highlights: highlights,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'safetyScore': safetyScore,
      'effectivenessScore': effectivenessScore,
      'suitabilityScore': suitabilityScore,
      'goodFor': goodFor,
      'notRecommendedFor': notRecommendedFor,
      'highlights': highlights?.map((x) => x.toJson()).toList(),
    };
  }
}

class HighlightModel {
  final String type; // 'good' or 'warning'
  final String description;

  HighlightModel({
    required this.type,
    required this.description,
  });

  factory HighlightModel.fromJson(Map<String, dynamic> json) {
    return HighlightModel(
      type: json['type'],
      description: json['description'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'type': type,
      'description': description,
    };
  }
}
```

```dart:ai_skincare/lib/models/conflict_model.dart
import 'ingredient_model.dart';
import 'product_model.dart';

class ConflictModel {
  final String id;
  final List<List<String>> ingredientPair;
  final String level;
  final String description;
  final List<String> recommendations;
  final String? source;
  final String createdAt;
  final String updatedAt;

  ConflictModel({
    required this.id,
    required this.ingredientPair,
    required this.level,
    required this.description,
    required this.recommendations,
    this.source,
    required this.createdAt,
    required this.updatedAt,
  });

  factory ConflictModel.fromJson(Map<String, dynamic> json) {
    return ConflictModel(
      id: json['id'],
      ingredientPair: List<List<String>>.from(
        json['ingredientPair'].map((x) => List<String>.from(x)),
      ),
      level: json['level'],
      description: json['description'],
      recommendations: List<String>.from(json['recommendations']),
      source: json['source'],
      createdAt: json['createdAt'],
      updatedAt: json['updatedAt'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'ingredientPair': ingredientPair,
      'level': level,
      'description': description,
      'recommendations': recommendations,
      'source': source,
      'createdAt': createdAt,
      'updatedAt': updatedAt,
    };
  }
}

class ConflictCheckResult {
  final List<ConflictDetail> conflicts;
  final List<List<IngredientModel>> compatibleGroups;
  final String? usageSuggestion;

  ConflictCheckResult({
    required this.conflicts,
    required this.compatibleGroups,
    this.usageSuggestion,
  });

  factory ConflictCheckResult.fromJson(Map<String, dynamic> json) {
    return ConflictCheckResult(
      conflicts: List<ConflictDetail>.from(
        json['conflicts'].map((x) => ConflictDetail.fromJson(x)),
      ),
      compatibleGroups: List<List<IngredientModel>>.from(json['compatibleGroups']
          .map((x) => List<IngredientModel>.from(
              x.map((y) => IngredientModel.fromJson(y))))),
      usageSuggestion: json['usageSuggestion'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'conflicts': conflicts.map((x) => x.toJson()).toList(),
      'compatibleGroups': compatibleGroups.map((group) => 
        group.map((ingredient) => ingredient.toJson()).toList()
      ).toList(),
      'usageSuggestion': usageSuggestion,
    };
  }
}

class ConflictDetail {
  final List<IngredientModel> ingredientPair;
  final String level;
  final String description;
  final List<String> recommendations;

  ConflictDetail({
    required this.ingredientPair,
    required this.level,
    required this.description,
    required this.recommendations,
  });

  factory ConflictDetail.fromJson(Map<String, dynamic> json) {
    return ConflictDetail(
      ingredientPair: List<IngredientModel>.from(
        json['ingredientPair'].map((x) => IngredientModel.fromJson(x)),
      ),
      level: json['level'],
      description: json['description'],
      recommendations: List<String>.from(json['recommendations']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'ingredientPair': ingredientPair.map((x) => x.toJson()).toList(),
      'level': level,
      'description': description,
      'recommendations': recommendations,
    };
  }
}

class ProductConflictResult extends ConflictCheckResult {
  final List<ProductModel> products;

  ProductConflictResult({
    required this.products,
    required List<ConflictDetail> conflicts,
    required List<List<IngredientModel>> compatibleGroups,
    String? usageSuggestion,
  }) : super(
          conflicts: conflicts,
          compatibleGroups: compatibleGroups,
          usageSuggestion: usageSuggestion,
        );

  factory ProductConflictResult.fromJson(Map<String, dynamic> json) {
    return ProductConflictResult(
      products: List<ProductModel>.from(
        json['products'].map((x) => ProductModel.fromJson(x)),
      ),
      conflicts: List<ConflictDetail>.from(
        json['conflicts'].map((x) => ConflictDetail.fromJson(x)),
      ),
      compatibleGroups: List<List<IngredientModel>>.from(json['compatibleGroups']
          .map((x) => List<IngredientModel>.from(
              x.map((y) => IngredientModel.fromJson(y))))),
      usageSuggestion: json['usageSuggestion'],
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final baseJson = super.toJson();
    baseJson['products'] = products.map((x) => x.toJson()).toList();
    return baseJson;
  }
}
```

```dart:ai_skincare/lib/services/api_service.dart
import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';
import '../models/skin_analysis_model.dart';
import '../models/product_model.dart';
import '../models/ingredient_model.dart';
import '../models/conflict_model.dart';

class ApiService {
  static const String baseUrl = 'https://api.ai-skincare.com/v1';
  static const String contentType = 'application/json';
  
  // ç¼“å­˜è·å–çš„token
  static String? _authToken;
  
  // è·å–è®¤è¯Token
  static Future<String?> getToken() async {
    if (_authToken != null) return _authToken;
    
    final prefs = await SharedPreferences.getInstance();
    _authToken = prefs.getString('auth_token');
    return _authToken;
  }
  
  // è®¾ç½®è®¤è¯Token
  static Future<void> setToken(String token) async {
    _authToken = token;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('auth_token', token);
  }
  
  // æ¸…é™¤è®¤è¯Token
  static Future<void> clearToken() async {
    _authToken = null;
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove('auth_token');
  }
  
  // åˆ›å»ºå¸¦è®¤è¯çš„è¯·æ±‚å¤´
  static Future<Map<String, String>> _getHeaders() async {
    final token = await getToken();
    return {
      'Content-Type': contentType,
      if (token != null) 'Authorization': 'Bearer $token',
    };
  }
  
  // å¤„ç†APIå“åº”
  static dynamic _handleResponse(http.Response response) {
    final statusCode = response.statusCode;
    final responseBody = json.decode(response.body);
    
    if (statusCode >= 200 && statusCode < 300) {
      return responseBody['data'];
    } else {
      final errorMessage = responseBody['error']['message'] ?? 'Unknown error occurred';
      throw ApiException(
        statusCode: statusCode,
        message: errorMessage,
        code: responseBody['error']['code'] ?? 'UNKNOWN_ERROR',
      );
    }
  }
  
  // GETè¯·æ±‚
  static Future<dynamic> get(String endpoint, {Map<String, dynamic>? queryParams}) async {
    final headers = await _getHeaders();
    final uri = Uri.parse('$baseUrl$endpoint').replace(queryParameters: queryParams);
    
    try {
      final response = await http.get(uri, headers: headers);
      return _handleResponse(response);
    } catch (e) {
      _handleException(e);
    }
  }
  
  // POSTè¯·æ±‚ (JSONæ•°æ®)
  static Future<dynamic> post(String endpoint, {Map<String, dynamic>? body}) async {
    final headers = await _getHeaders();
    final uri = Uri.parse('$baseUrl$endpoint');
    
    try {
      final response = await http.post(
        uri,
        headers: headers,
        body: body != null ? json.encode(body) : null,
      );
      return _handleResponse(response);
    } catch (e) {
      _handleException(e);
    }
  }
  
  // POSTè¯·æ±‚ (è¡¨å•æ•°æ®å’Œæ–‡ä»¶)
  static Future<dynamic> postMultipart(
    String endpoint, {
    required File file,
    String fileField = 'image',
    Map<String, String>? fields,
  }) async {
    final token = await getToken();
    final uri = Uri.parse('$baseUrl$endpoint');
    
    try {
      final request = http.MultipartRequest('POST', uri);
      
      // æ·»åŠ æ–‡ä»¶
      final fileStream = http.ByteStream(file.openRead());
      final length = await file.length();
      final multipartFile = http.MultipartFile(
        fileField,
        fileStream,
        length,
        filename: file.path.split('/').last,
      );
      request.files.add(multipartFile);
      
      // æ·»åŠ å…¶ä»–å­—æ®µ
      if (fields != null) {
        request.fields.addAll(fields);
      }
      
      // æ·»åŠ å¤´ä¿¡æ¯
      if (token != null) {
        request.headers['Authorization'] = 'Bearer $token';
      }
      
      // å‘é€è¯·æ±‚
      final streamedResponse = await request.send();
      final response = await http.Response.fromStream(streamedResponse);
      
      return _handleResponse(response);
    } catch (e) {
      _handleException(e);
    }
  }
  
  // PUTè¯·æ±‚
  static Future<dynamic> put(String endpoint, {Map<String, dynamic>? body}) async {
    final headers = await _getHeaders();
    final uri = Uri.parse('$baseUrl$endpoint');
    
    try {
      final response = await http.put(
        uri,
        headers: headers,
        body: body != null ? json.encode(body) : null,
      );
      return _handleResponse(response);
    } catch (e) {
      _handleException(e);
    }
  }
  
  // DELETEè¯·æ±‚
  static Future<dynamic> delete(String endpoint) async {
    final headers = await _getHeaders();
    final uri = Uri.parse('$baseUrl$endpoint');
    
    try {
      final response = await http.delete(uri, headers: headers);
      return _handleResponse(response);
    } catch (e) {
      _handleException(e);
    }
  }
  
  // å¼‚å¸¸å¤„ç†
  static void _handleException(dynamic e) {
    if (e is ApiException) {
      throw e;
    } else if (e is SocketException) {
      throw ApiException(
        statusCode: 0,
        message: 'No internet connection',
        code: 'NETWORK_ERROR',
      );
    } else {
      throw ApiException(
        statusCode: 500,
        message: e.toString(),
        code: 'UNKNOWN_ERROR',
      );
    }
  }
  
  // ç”¨æˆ·æ³¨å†Œ
  static Future<Map<String, dynamic>> register({
    required String username,
    required String email,
    required String password,
    String? phoneNumber,
  }) async {
    final response = await post('/auth/register', body: {
      'username': username,
      'email': email,
      'password': password,
      if (phoneNumber != null) 'phoneNumber': phoneNumber,
    });
    
    if (response['token'] != null) {
      await setToken(response['token']);
    }
    
    return response;
  }
  
  // ç”¨æˆ·ç™»å½•
  static Future<Map<String, dynamic>> login({
    required String email,
    required String password,
  }) async {
    final response = await post('/auth/login', body: {
      'email': email,
      'password': password,
    });
    
    if (response['token'] != null) {
      await setToken(response['token']);
    }
    
    return response;
  }
  
  // é€€å‡ºç™»å½•
  static Future<void> logout() async {
    await clearToken();
  }
  
  // è·å–ç”¨æˆ·ä¿¡æ¯
  static Future<Map<String, dynamic>> getUserInfo() async {
    return await get('/users/me');
  }
  
  // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
  static Future<Map<String, dynamic>> updateUserInfo({
    String? username,
    String? avatarUrl,
    String? skinType,
    List<String>? concerns,
  }) async {
    final body = <String, dynamic>{};
    if (username != null) body['username'] = username;
    if (avatarUrl != null) body['avatarUrl'] = avatarUrl;
    if (skinType != null) body['skinType'] = skinType;
    if (concerns != null) body['concerns'] = concerns;
    
    return await put('/users/me', body: body);
  }
  
  // ä¸Šä¼ å›¾ç‰‡è¿›è¡Œè‚Œè‚¤åˆ†æ
  static Future<SkinAnalysisModel> uploadSkinImage({
    required File image,
    Map<String, dynamic>? quizData,
  }) async {
    final Map<String, String> fields = {};
    if (quizData != null) {
      fields['quizData'] = json.encode(quizData);
    }
    
    final response = await postMultipart(
      '/skin-analysis/detect',
      file: image,
      fields: fields,
    );
    
    return SkinAnalysisModel.fromJson(response);
  }
  
  // è·å–è‚Œè‚¤åˆ†æå†å²
  static Future<Map<String, dynamic>> getSkinAnalysisHistory({
    int page = 1,
    int limit = 10,
  }) async {
    return await get('/skin-analysis/history', queryParams: {
      'page': page.toString(),
      'limit': limit.toString(),
    });
  }
  
  // è·å–è‚Œè‚¤åˆ†æè¯¦æƒ…
  static Future<SkinAnalysisModel> getSkinAnalysisDetail(String analysisId) async {
    final response = await get('/skin-analysis/$analysisId');
    return SkinAnalysisModel.fromJson(response);
  }
  
  // ä¸Šä¼ å›¾ç‰‡è¿›è¡Œäº§å“åˆ†æ
  static Future<Map<String, dynamic>> scanProduct(File image) async {
    return await postMultipart('/product-analysis/scan', file: image);
  }
  
  // æœç´¢äº§å“
  static Future<Map<String, dynamic>> searchProducts({
    required String query,
    String? category,
    String? brand,
    int page = 1,
    int limit = 10,
  }) async {
    final queryParams = <String, dynamic>{
      'query': query,
      'page': page.toString(),
      'limit': limit.toString(),
    };
    
    if (category != null) queryParams['category'] = category;
    if (brand != null) queryParams['brand'] = brand;
    
    return await get('/products/search', queryParams: queryParams);
  }
  
  // è·å–äº§å“è¯¦æƒ…
  static Future<ProductModel> getProductDetail(String productId) async {
    final response = await get('/products/$productId');
    return ProductModel.fromJson(response);
  }
  
  // è·å–æˆåˆ†è¯¦æƒ…
  static Future<IngredientModel> getIngredientDetail(String ingredientId) async {
    final response = await get('/ingredients/$ingredientId');
    return IngredientModel.fromJson(response);
  }
  
  // æœç´¢æˆåˆ†
  static Future<Map<String, dynamic>> searchIngredients({
    required String query,
    String? category,
    String? function,
    int page = 1,
    int limit = 10,
  }) async {
    final queryParams = <String, dynamic>{
      'query': query,
      'page': page.toString(),
      'limit': limit.toString(),
    };
    
    if (category != null) queryParams['category'] = category;
    if (function != null) queryParams['function'] = function;
    
    return await get('/ingredients/search', queryParams: queryParams);
  }
  
  // æ£€æµ‹æˆåˆ†å†²çª
  static Future<ConflictCheckResult> checkIngredientConflicts(
    List<String> ingredientIds,
  ) async {
    final response = await post('/conflict-detection/check', body: {
      'ingredientIds': ingredientIds,
    });
    
    return ConflictCheckResult.fromJson(response);
  }
  
  // æ£€æµ‹äº§å“å†²çª
  static Future<ProductConflictResult> checkProductConflicts(
    List<String> productIds,
  ) async {
    final response = await post('/conflict-detection/products', body: {
      'productIds': productIds,
    });
    
    return ProductConflictResult.fromJson(response);
  }
  
  // è·å–å¤©æ°”å’ŒæŠ¤è‚¤å»ºè®®
  static Future<Map<String, dynamic>> getWeatherAdvice({
    double? latitude,
    double? longitude,
  }) async {
    final queryParams = <String, dynamic>{};
    
    if (latitude != null) queryParams['latitude'] = latitude.toString();
    if (longitude != null) queryParams['longitude'] = longitude.toString();
    
    return await get('/weather-advice', queryParams: queryParams);
  }
}

class ApiException implements Exception {
  final int statusCode;
  final String message;
  final String code;
  
  ApiException({
    required this.statusCode,
    required this.message,
    required this.code,
  });
  
  @override
  String toString() => 'ApiException: [$statusCode] $code - $message';
}
```

```yaml:ai_skincare/pubspec.yaml

```

Read file: ai_skincare/pubspec.yaml




```yaml:ai_skincare/pubspec.yaml
name: ai_skincare
description: "AI powered skincare product advisor app"
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.7.2

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  get: ^4.6.6  # ç”¨äºçŠ¶æ€ç®¡ç†å’Œè·¯ç”±
  flutter_svg: ^2.0.10  # ç”¨äºSVGå›¾æ ‡
  cached_network_image: ^3.3.1  # ç”¨äºå›¾ç‰‡ç¼“å­˜
  image_picker: ^1.0.7  # ç”¨äºç›¸æœºå’Œå›¾åº“è®¿é—®
  shared_preferences: ^2.2.2  # ç”¨äºæœ¬åœ°æ•°æ®å­˜å‚¨
  lottie: ^3.0.0  # ç”¨äºåŠ¨ç”»æ•ˆæœ
  flutter_rating_bar: ^4.0.1  # ç”¨äºè¯„åˆ†ç»„ä»¶
  flutter_launcher_icons: ^0.14.3  # ç”¨äºåº”ç”¨å›¾æ ‡
  flutter_native_splash: ^2.3.10  # ç”¨äºå¯åŠ¨å±
  dio: ^5.4.1  # ç”¨äºç½‘ç»œè¯·æ±‚
  http: ^1.2.0  # ç”¨äºAPIè¯·æ±‚

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  assets:
    - assets/images/
    - assets/icons/
    - assets/animations/

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  fonts:
    - family: Poppins
      fonts:
        - asset: assets/fonts/Poppins-Regular.ttf
        - asset: assets/fonts/Poppins-Medium.ttf
          weight: 500
        - asset: assets/fonts/Poppins-SemiBold.ttf
          weight: 600
        - asset: assets/fonts/Poppins-Bold.ttf
          weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package
```

```markdown:README.md
# AI è‚Œè‚¤æ£€æµ‹ App

![App Logo](ai_skincare/assets/images/logo.png)

ä¸€æ¬¾åŸºäºAIæŠ€æœ¯çš„è‚Œè‚¤åˆ†æå’ŒæŠ¤è‚¤äº§å“æ¨èåº”ç”¨ã€‚

## åŠŸèƒ½ç‰¹ç‚¹

- **è‚Œè‚¤åˆ†æ**: é€šè¿‡æ‘„åƒå¤´æ‹æ‘„æˆ–ä¸Šä¼ ç…§ç‰‡ï¼ŒAIæŠ€æœ¯å®æ—¶åˆ†æè‚Œè‚¤çŠ¶å†µ
- **äº§å“åˆ†æ**: æ‰«ææˆ–ä¸Šä¼ äº§å“å›¾ç‰‡ï¼Œæ™ºèƒ½è¯†åˆ«æˆåˆ†å¹¶åˆ†æå®‰å…¨æ€§
- **æˆåˆ†å†²çªæ£€æµ‹**: æ£€æµ‹å¤šç§æŠ¤è‚¤å“ä¹‹é—´å¯èƒ½å­˜åœ¨çš„æˆåˆ†å†²çª
- **ä¸ªæ€§åŒ–æ¨è**: æ ¹æ®è‚Œè‚¤çŠ¶å†µæä¾›ä¸ªæ€§åŒ–çš„äº§å“å’ŒæŠ¤ç†å»ºè®®
- **æŠ¤è‚¤æ—¥è®°**: è®°å½•æ¯æ—¥è‚Œè‚¤çŠ¶æ€å’ŒæŠ¤è‚¤äº§å“ä½¿ç”¨æƒ…å†µ
- **å¤©æ°”å»ºè®®**: æ ¹æ®å½“åœ°å¤©æ°”æƒ…å†µæä¾›ç›¸åº”çš„æŠ¤è‚¤å»ºè®®

## æŠ€æœ¯æ¶æ„

- **å‰ç«¯æ¡†æ¶**: Flutter
- **çŠ¶æ€ç®¡ç†**: GetX
- **ç½‘ç»œè¯·æ±‚**: HTTP/Dio
- **æœ¬åœ°å­˜å‚¨**: Shared Preferences
- **åç«¯API**: RESTful API
- **AIæ¨¡å‹**: åŸºäºæ·±åº¦å­¦ä¹ çš„è‚Œè‚¤åˆ†æå’Œå›¾åƒè¯†åˆ«æ¨¡å‹

## é¡¹ç›®ç»“æ„

```
ai_skincare/
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ config/           # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ models/           # æ•°æ®æ¨¡å‹
â”‚   â”œâ”€â”€ screens/          # é¡µé¢UI
â”‚   â”œâ”€â”€ services/         # æœåŠ¡å±‚
â”‚   â”œâ”€â”€ themes/           # ä¸»é¢˜é…ç½®
â”‚   â”œâ”€â”€ utils/            # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ widgets/          # å¯å¤ç”¨ç»„ä»¶
â”‚   â””â”€â”€ main.dart         # åº”ç”¨å…¥å£
â”œâ”€â”€ assets/               # é™æ€èµ„æº
â”‚   â”œâ”€â”€ images/           # å›¾ç‰‡èµ„æº
â”‚   â”œâ”€â”€ icons/            # å›¾æ ‡èµ„æº
â”‚   â”œâ”€â”€ animations/       # åŠ¨ç”»èµ„æº
â”‚   â””â”€â”€ fonts/            # å­—ä½“èµ„æº
â””â”€â”€ test/                 # æµ‹è¯•æ–‡ä»¶
```

## API æ–‡æ¡£

è¯¦ç»†çš„APIæ–‡æ¡£è¯·æŸ¥çœ‹ [api_documentation.md](api_documentation.md)

## å®‰è£…è¿è¡Œ

### ç¯å¢ƒè¦æ±‚

- Flutter SDK: 3.7.2 æˆ–æ›´é«˜
- Dart SDK: 3.0.0 æˆ–æ›´é«˜
- Android Studio / VS Code
- Android SDK / Xcode

### å®‰è£…æ­¥éª¤

1. å…‹éš†é¡¹ç›®
   ```
   git clone https://github.com/your-username/ai-skincare.git
   ```

2. å®‰è£…ä¾èµ–
   ```
   cd ai-skincare
   flutter pub get
   ```

3. è¿è¡Œåº”ç”¨
   ```
   flutter run
   ```

## è®¾è®¡ç¨¿å’ŒåŸå‹

é¡¹ç›®è®¾è®¡ç¨¿å’ŒåŸå‹æ–‡ä»¶ä½äº `prototype/` ç›®å½•ä¸‹ï¼ŒåŒ…æ‹¬:
- é¡µé¢å¸ƒå±€è®¾è®¡
- äº¤äº’æµç¨‹å›¾
- è‰²å½©è§„èŒƒ
- ç»„ä»¶åº“

## å¼€å‘å›¢é˜Ÿ

- äº§å“ç»ç†: [å§“å]
- UI/UXè®¾è®¡: [å§“å]
- å‰ç«¯å¼€å‘: [å§“å]
- åç«¯å¼€å‘: [å§“å]
- AIå·¥ç¨‹å¸ˆ: [å§“å]

## å¼€æºåè®®

æœ¬é¡¹ç›®é‡‡ç”¨ [MIT åè®®](LICENSE)ã€‚
```
å·²å®ŒæˆAIè‚Œè‚¤æ£€æµ‹åº”ç”¨çš„APIæ–‡æ¡£å’Œæ•°æ®æ¨¡å‹çš„åˆ›å»ºå·¥ä½œã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å®Œæˆçš„å†…å®¹ï¼š

1. åˆ›å»ºäº†è¯¦ç»†çš„APIæ–‡æ¡£ï¼ˆapi_documentation.mdï¼‰ï¼ŒåŒ…å«äº†æ‰€æœ‰åç«¯æ¥å£çš„è¯¦ç»†è¯´æ˜å’Œæ•°æ®ç»“æ„ã€‚æ–‡æ¡£æ¶µç›–äº†ç”¨æˆ·è®¤è¯ã€è‚Œè‚¤åˆ†æã€äº§å“åˆ†æã€æˆåˆ†å†²çªæ£€æµ‹ç­‰åŠŸèƒ½æ¨¡å—ã€‚

2. å®ç°äº†æ•°æ®æ¨¡å‹ç±»ï¼š
   - `SkinAnalysisModel`ï¼šè‚Œè‚¤åˆ†ææ•°æ®æ¨¡å‹
   - `ProductModel`ï¼šäº§å“æ•°æ®æ¨¡å‹
   - `IngredientModel`ï¼šæˆåˆ†æ•°æ®æ¨¡å‹
   - `ConflictModel`ï¼šæˆåˆ†å†²çªæ£€æµ‹æ¨¡å‹

3. åˆ›å»ºäº†`ApiService`æœåŠ¡ç±»ï¼Œå°è£…äº†æ‰€æœ‰ä¸åç«¯APIé€šä¿¡çš„æ–¹æ³•ï¼ŒåŒ…æ‹¬ç”¨æˆ·è®¤è¯ã€å›¾ç‰‡ä¸Šä¼ ã€æ•°æ®æŸ¥è¯¢ç­‰åŠŸèƒ½ã€‚

4. æ›´æ–°äº†é¡¹ç›®ä¾èµ–ï¼Œæ·»åŠ äº†httpåŒ…ç”¨äºAPIè¯·æ±‚ã€‚

5. ç¼–å†™äº†é¡¹ç›®READMEæ–‡æ¡£ï¼ŒåŒ…å«äº†é¡¹ç›®æ¦‚è¿°ã€åŠŸèƒ½ç‰¹ç‚¹ã€æŠ€æœ¯æ¶æ„ã€é¡¹ç›®ç»“æ„ã€å®‰è£…è¯´æ˜ç­‰å†…å®¹ã€‚

è¿™äº›æ–‡ä»¶ä¸ºåº”ç”¨ç¨‹åºæä¾›äº†å®Œæ•´çš„æ•°æ®å±‚å’ŒæœåŠ¡å±‚ï¼Œå¯ä»¥ä¸Flutter UIå±‚æ— ç¼é›†æˆï¼Œå®ç°å®Œæ•´çš„è‚Œè‚¤åˆ†æå’Œäº§å“æ¨èåŠŸèƒ½ã€‚
